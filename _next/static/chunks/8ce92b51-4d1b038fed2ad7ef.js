"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[362],{4288:function(t,e,n){n.d(e,{KB:function(){return un}});var o=n(3029),i=n(4020),r=n(9279),s=n(8202),a=n(9499),u=n.n(a),c=n(3283),m=n(3163),d=n(3550),p=n.n(d),l=n(9386),h=n(9210),g=n(3776),A=n.n(g),f=n(4098),k=n.n(f),w=n(7907),S=n(3453),y=n(4780),M=n(9791),T=n(7845),v=n(324),P=n(6525),B=(n(5273),n(8764).Buffer),b=[{wrapper:"2B5Qedoo95Pjpv9xVPw82bbmcGDGCNHroKpzQE2CNHRZ",underlying:"CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",underlyingDecimals:6,wrapperUnderlyingTokens:"3YCGgStAV9H7TdPYdBnRP8yoH4Zqdmyt7xo6KB4Wa8xt",mint:"C9xqJe3gMTUDKidZsZ6jJ7tL9zSLimDUKVpgUbLZnNbi",decimals:9},{wrapper:"2ffwMLE4dxSv59eYXhfhfuS81kz6gzf6DZjdBxRHZz9A",underlying:"AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",underlyingDecimals:6,wrapperUnderlyingTokens:"H5tnZcfHCzHueNnfd6foeBBUUW4g7qXKt6rKzT7wg6oP",mint:"FTT9rBBrYwcHam4qLvkzzzhrsihYMbZ3k6wJbdoahxAt",decimals:9},{wrapper:"3A85wiQg2REhBVxVS1CjDaS333TBNM2g37BbdNGSMheg",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"764FaQrrREvNTpaH2yXyrPZgVBaXA7AXM8vyCaevXitD",mint:"BtX7AfzEJLnU8KQR1AgHrhGH5s2AHUTbfjhUQP8BhPvi",decimals:10},{wrapper:"7hWjnVC6FNkmmgjq88LEnRycrKvxVB1MsJ6FQcrvxe4n",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"B22gDMgN2tNWmvyzhb5tamJKanWcUUUw2zN3h3qjgQg8",mint:"9999j2A8sXUtHtDoQdk528oVzhaKBsXyRGZ67FKGoi7H",decimals:9},{wrapper:"8zooyPZrq2mth917VrHLtNTk6GvAhc2KgdB4DGBXYyke",underlying:"AUrMpCDYYcPuHhyNX8gEEqbmDPFUpBpHrNW3vPeCFn5Z",underlyingDecimals:9,wrapperUnderlyingTokens:"7ZZyhVde6ZmnVMuFnrg3mRPHhvfBixLdEo7RnwxTtpF7",mint:"EY3s4nXTzHDiiysmjvj7zWP6yAX3n4xHmXkJWD1w1tGP",decimals:15},{wrapper:"93qsLbASEG8DmtSB2MEVaa25KvEm2afh5rzbaAJHLi5A",underlying:"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",underlyingDecimals:8,wrapperUnderlyingTokens:"4fUL9yLbFZEuG32SaCjWqJXwDTBFNnipteBWxMvvFoC8",mint:"KNVfdSJyq1pRQk9AKKv1g5uyGuk6wpm4WG16Bjuwdma",decimals:9},{wrapper:"ACvLVgR3UKdDB3b1QapsbJsPXaUrBPdJGDfiFnMYMXoz",underlying:"F6v4wfAdJB8D8p77bMXZgYt8TDKsYxLYxH5AFhUkYx9W",underlyingDecimals:6,wrapperUnderlyingTokens:"AvqMJWHsZscPWTAUcj8dZi2ch6XQEHMpiCMprfFovaU",mint:"LUNGEjUXyP48nrC1GYY5o4eTAkwm4RdX8BxFUxWJBLB",decimals:9},{wrapper:"AnKLLfpMcceM6YXtJ9nGxYekVXqfWy8WNsMZXoQTCVQk",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"77XHXCWYQ76E9Q3uCuz1geTaxsqJZf9RfX5ZY7yyLDYt",mint:"JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",decimals:9},{wrapper:"CGxMr5UrTjApBjU656N9NBAsGby4fWs1KgVtueQ8WKt6",underlying:"AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",underlyingDecimals:6,wrapperUnderlyingTokens:"7dVPR6jx3hKyNfuHPo3WtWdUpH4eh4Up4rfFhLHZqwy3",mint:"FTT8cGNp3rfTC6c44uPTuEFLqmsVDhjd2BhH65v2uppr",decimals:8},{wrapper:"D231Uoh24bXtUtWN51ZbFAFSBmGT3zuuEAHZNuCmtRjN",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"C39Wq6X98TLcrnYCMkcHQhwUurkQMUdibUCpf2fVBDsm",mint:"FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",decimals:9},{wrapper:"EhQqUmkUXXnxmV7yA6PDrQWvLgSd9HkrwdDKk1B5m6Tc",underlying:"CbNYA9n3927uXUukee2Hf4tm3xxkffJPPZvGazc2EAH1",underlyingDecimals:8,wrapperUnderlyingTokens:"8YC5eCS99umbK9K9LnHnTMMjnr7EWg1gam5maNB6uf9d",mint:"EU9aLffrTckFCs16da6CppHy63fAxMPF9ih1erQTuuRt",decimals:9},{wrapper:"EwWpia5t9Twiwdi8ghK8e8JHaf6ShNU9jmoYpvdZhBwC",underlying:"9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",underlyingDecimals:6,wrapperUnderlyingTokens:"9YB1zRL4ETuQFG8ZK1yD4GHBVDmH81EzwuSj75zdnKhK",mint:"UST8SCn7jrqsq51odVLqcmvnC658HkqrKrPL3w2hHQ7",decimals:8},{wrapper:"F9TsAsh5RirU3LqyTJECLQEGXnF4RQT7ckvexCP1KNTu",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"BSTjdztBrsptuxfz9JHS31Wc9CknpLeL1wqZjeVs1Ths",mint:"AEUT5uFm1D575FVCoQd5Yq891FJEqkncZUbBFoFcAhTV",decimals:9},{wrapper:"FCgoT8RpsopdM5QT6AB98NUfUnDnu7y865MFpRx93JrS",underlying:"EzfgjvkSwthhgHaceR3LnKXUoRkP6NUhfghdaHAj1tUv",underlyingDecimals:8,wrapperUnderlyingTokens:"5yugfArBAUZJJBUCRWPuiLyi6CWp1f67H9xgg3hcgSkx",mint:"FTT9GrHBVHvDeUTgLU8FxVJouGqg9uiWGmmjETdm32Sx",decimals:9},{wrapper:"FDGtFWVhEb1zxnaW2FzogeGDxLoAV7Cu9XdNYPEVwqt",underlying:"8wv2KAykQstNAj2oW6AHANGBiFKVFhvMiyyzzjhkmGvE",underlyingDecimals:6,wrapperUnderlyingTokens:"4R6PmC8BJcPDBsEMGpXpLCnFFkUZhEgZy6pMNtc2LqA4",mint:"KUANeD8EQvwpT1W7QZDtDqctLEh2FfSTy5pThE9CogT",decimals:9},{wrapper:"FPuYMuodknZuQKHA8Wp4PBbp52Qu8nK2oAuwedp2WfM3",underlying:"9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",underlyingDecimals:6,wrapperUnderlyingTokens:"GxpyQZi5VkZDSq5TUycMau11sCkQkVCa8xYhBgiPMsyK",mint:"UST98bfV6EASdTFQrRwCBczpehdMFwYCUdLT5tEbhpW",decimals:9},{wrapper:"Ffxi5TSpFV9NeV5KyNDCC7fWnFoFd2bDcL1eViSAE2M2",underlying:"CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",underlyingDecimals:6,wrapperUnderlyingTokens:"5s2et753hMXV945U3p5uz6RQqMkZGCPEjKjNPdUcCLLF",mint:"CASHedBw9NfhsLBXq1WNVfueVznx255j8LLTScto3S6s",decimals:8},{wrapper:"G4gRGymKo7MGzGZup12JS39YVCvy8YMM6KY9AmcKi5iw",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"AQhP39mE4o6BYNwnwYqnz7ZobkPBSLpCg8WvEESq1viZ",mint:"88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",decimals:8},{wrapper:"GiLSv94Wwyd6suH57Fu6HjEKsMxhNGfEwKn9vT22me1p",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"3cjAWoyDcco8UVCN17keNUNHoyz37ctgDa7G6zkeb81Y",mint:"T8KdT8hDzNhbGx5sjpEUxepnbDB1TZoCa7vtC5JjsMw",decimals:8},{wrapper:"GpkFF2nPfjUcsavgDGscxaUEQ2hYJ563AXXtU8ohiZ7c",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"6hYDFhZ5ddfzoqaAbzRHm8mzG2MQzYQV9295sQHsvNBV",mint:"SBTCB6pWqeDo6zGi9WVRMLCsKsN6JiR1RMUqvLtgSRv",decimals:8},{wrapper:"fvSvtHNFuDHrAN82YEyBApRs3U6vUGCLzKGMuPmCaF8",underlying:"2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",underlyingDecimals:6,wrapperUnderlyingTokens:"4JWyJ4ZYsQ8uiYue2tTEqcHcFXrDuaQ1rsyjNFfrZm65",mint:"SL819j8K9FuFPL84UepVcFkEZqDUUvVzwDmJjCHySYj",decimals:8}];const I={version:"0.1.0",name:"jupiter",instructions:[{name:"mercurialExchange",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"poolAuthority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceTokenAccount",isMut:!0,isSigner:!1},{name:"destinationTokenAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberExchange",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapAuthority",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"feesTokenAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapAuthority",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"feesTokenAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberAddDecimalsDeposit",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberAddDecimalsWithdraw",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"senchaExchange",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!0,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"inputFeesAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"outputFeesAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"serumSwap",accounts:[{name:"market",accounts:[{name:"market",isMut:!0,isSigner:!1},{name:"openOrders",isMut:!0,isSigner:!1},{name:"requestQueue",isMut:!0,isSigner:!1},{name:"eventQueue",isMut:!0,isSigner:!1},{name:"bids",isMut:!0,isSigner:!1},{name:"asks",isMut:!0,isSigner:!1},{name:"coinVault",isMut:!0,isSigner:!1},{name:"pcVault",isMut:!0,isSigner:!1},{name:"vaultSigner",isMut:!1,isSigner:!1}]},{name:"authority",isMut:!1,isSigner:!0},{name:"orderPayerTokenAccount",isMut:!0,isSigner:!1},{name:"coinWallet",isMut:!0,isSigner:!1},{name:"pcWallet",isMut:!0,isSigner:!1},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"side",type:{defined:"Side"}},{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"tokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"stepTokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"cropperTokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"raydiumSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"ammTargetOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"raydiumSwapV2",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"aldrinSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"side",type:{defined:"Side"}},{name:"platformFeeBps",type:"u8"}]},{name:"aldrinV2Swap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"curve",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"side",type:{defined:"Side"}},{name:"platformFeeBps",type:"u8"}]},{name:"cremaTokenSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"poolSourceTokenAccount",isMut:!0,isSigner:!1},{name:"poolDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"poolTicksAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"lifinityTokenSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"amm",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceInfo",isMut:!0,isSigner:!1},{name:"destinationInfo",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"feeAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"pythAccount",isMut:!1,isSigner:!1},{name:"pythPcAccount",isMut:!1,isSigner:!1},{name:"configAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"cykuraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"signer",isMut:!1,isSigner:!0},{name:"factoryState",isMut:!1,isSigner:!1},{name:"poolState",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"inputVault",isMut:!0,isSigner:!1},{name:"outputVault",isMut:!0,isSigner:!1},{name:"lastObservationState",isMut:!0,isSigner:!1},{name:"coreProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"whirlpoolSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"aToB",type:"bool"},{name:"platformFeeBps",type:"u8"}]},{name:"riskCheckAndFee",accounts:[{name:"tokenLedger",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"initializeTokenLedger",accounts:[{name:"tokenLedger",isMut:!0,isSigner:!0},{name:"payer",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"setTokenLedger",accounts:[{name:"tokenLedger",isMut:!0,isSigner:!1},{name:"tokenAccount",isMut:!1,isSigner:!1}],args:[]},{name:"createOpenOrders",accounts:[{name:"openOrders",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"market",isMut:!1,isSigner:!1}],args:[]}],accounts:[{name:"tokenLedger",type:{kind:"struct",fields:[{name:"tokenAccount",type:"publicKey"},{name:"amount",type:"u64"}]}}],types:[{name:"Swap",type:{kind:"struct",fields:[{name:"tokens",type:"u64"},{name:"minTokens",type:"u64"},{name:"side",type:{defined:"Side"}}]}},{name:"Swap",type:{kind:"struct",fields:[{name:"tokens",type:"u64"},{name:"minTokens",type:"u64"},{name:"side",type:{defined:"Side"}}]}},{name:"Swap",type:{kind:"struct",fields:[{name:"amountIn",type:"u64"},{name:"minimumAmountOut",type:"u64"}]}},{name:"Swap",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"otherAmountThreshold",type:"u64"},{name:"sqrtPriceLimit",type:"u128"},{name:"amountSpecifiedIsInput",type:"bool"},{name:"aToB",type:"bool"}]}},{name:"SwapInstrution",type:{kind:"enum",variants:[{name:"Swap",fields:[{defined:"Swap"}]}]}},{name:"Side",type:{kind:"enum",variants:[{name:"Bid"},{name:"Ask"}]}},{name:"Direction",type:{kind:"enum",variants:[{name:"LeftToRight"},{name:"RightToLeft"}]}}],errors:[{code:6e3,name:"SlippageToleranceExceeded",msg:"Slippage tolerance exceeded"},{code:6001,name:"InvalidTokenLedger",msg:"Invalid token ledger"},{code:6002,name:"MissingTokenLedger",msg:"Missing token ledger"},{code:6003,name:"MissingMercurialExchangeTokenAccount",msg:"Missing mercurial exchange token account"},{code:6004,name:"LedgerTokenAccountDoesNotMatch",msg:"Ledger token account does not match"},{code:6005,name:"MissingPlatformFeeAccount",msg:"Missing platform fee account"},{code:6006,name:"InvalidCalculation",msg:"Invalid calculation"}]},F=new i.PublicKey("So11111111111111111111111111111111111111112"),D=new i.PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),N=new i.PublicKey("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY"),O={devnet:"https://api.jup.ag/api/markets/cache/devnet","mainnet-beta":"https://cache.jup.ag/markets?v=3",testnet:"https://api.jup.ag/api/markets/cache/devnet"},E=new i.PublicKey("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),K=new i.PublicKey("AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6"),q=new i.PublicKey("CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4"),C=new i.PublicKey("DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB"),U=new i.PublicKey("CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh"),R=new i.PublicKey("SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ"),L=new i.PublicKey("EewxydAPCCVuNEyrVN68PuSYdQ7wKn27V9Gjeoi8dy3S"),x=new i.PublicKey("6MLxLqiXaaSUpkgMnWDTuejNZEz3kE7k2woyHGVFw319"),V=new i.PublicKey("BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9"),_=new i.PublicKey("MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky"),W=new i.PublicKey("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"),G=new i.PublicKey("cysPXAjehMpVKUapzbMCCnpFxUFFryEWEaLgnb9NrR8"),z=new i.PublicKey("DBsMwKfeoUHhxMi9x6wd2AsT12UwUCssjNbUzu1aKgqj"),Q=["StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT","DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz"],H=Object.freeze({TransactionNotConfirmed:{code:7e3,name:"TransactionNotConfirmed",msg:"Transaction was not confirmed"},BalancesNotExtractedProperly:{code:7001,name:"BalancesNotExtractedProperly",msg:"Balances cannot be extracted properly"},...I.errors.reduce(((t,e)=>({...t,[e.name]:e})),{})});class j extends l.Ar{constructor(t){const e=(0,l.Ik)(32);super(e.span,t),this.layout=void 0,this.layout=e}getSpan(t,e){return this.layout.getSpan(t,e)}decode(t,e){return new i.PublicKey(this.layout.decode(t,e))}encode(t,e,n){return this.layout.encode(t.toBuffer(),e,n)}}const Y=t=>new j(t);class X extends l.Ar{constructor(t=8,e){const n=(0,l.Ik)(t);super(n.span,e),this.layout=void 0,this.layout=n}getSpan(t,e){return this.layout.getSpan(t,e)}decode(t,e){return new o.u64(this.layout.decode(t,e),10,"le")}encode(t,e,n){return this.layout.encode(t.toArrayLike(B,"le",this.layout.span),e,n)}}const Z=t=>new X(8,t),J=t=>new X(16,t),$=(0,l.n_)([(0,l.u8)("version"),(0,l.u8)("isInitialized"),(0,l.u8)("nonce"),Y("ammId"),Y("serumProgramId"),Y("serumMarket"),Y("tokenProgramId"),Y("tokenAAccount"),Y("tokenBAccount"),Y("poolMint"),Y("mintA"),Y("mintB")]),tt=(0,l.n_)([(0,l.u8)("isInitialized"),Y("stateOwner"),Y("feeOwner"),Z("initialSupply"),Z("returnFeeNumerator"),Z("fixedFeeNumerator"),Z("feeDenominator"),(0,l.u8)("curveType"),(0,l.Ik)(32,"curveParameters")]),et=new i.PublicKey("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),nt=(t,e)=>{const n=e.owner,o=$.decode(e.data),[i]=(0,m.findProgramAddressSync)([t.toBuffer()],n);return{programId:n,authority:i,version:o.version,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:o.ammId,serumProgramId:o.serumProgramId,tokenProgramId:o.tokenProgramId,tokenAAccount:o.tokenAAccount,tokenBAccount:o.tokenBAccount,serumMarket:o.serumMarket,poolMint:o.poolMint,mintA:o.mintA,mintB:o.mintB}},ot={Bid:{bid:{}},Ask:{ask:{}}},it=new i.PublicKey("JUP2jxvXaqu7NQY1GmNF4m1vodw12LVXYxbFL2uJvfo"),rt=new c.$r(I,it,{}),st=[new i.PublicKey("7h51TX1pNvSaNyjg4koKroJqoe7atKB7xWUfir7ZqX81"),new i.PublicKey("HgeLVK1nJ1kNdWSUNCKj6DfGqfhwgx67dfGPRcBSdE2d"),new i.PublicKey("8ME9HwwchNknEVrcCSKYAQCa1YAYi3LZrEXJrY4ZNkkg"),new i.PublicKey("Edg9J3CMky9AVJq2WrSar2JR38jFkg4S7vAW7Xsix8oV"),new i.PublicKey("B5mW68TkDewnKvWNc2trkmmdSRxcCjZz3Yd9BWxQTSRU"),new i.PublicKey("7E3TDrnS2zEp8uVri8EtPU8MyQ3qjLTc6cCGJAnAM48p")],at=st[Math.floor(Math.random()*st.length)];function ut(t,e,n,i){return{swapProgram:_,swapState:t.ammId,tokenProgram:o.TOKEN_PROGRAM_ID,poolAuthority:t.authority,userTransferAuthority:i,sourceTokenAccount:e,destinationTokenAccount:n}}function ct(t,e,n,i){const[r]=(0,m.findProgramAddressSync)([new Uint8Array(B.from("amm authority".replace("\xa0"," "),"utf-8"))],E);if(!t.serumMarketKeys)throw new Error("RaydiumAmm is missing serumMarketKeys");return{swapProgram:E,tokenProgram:o.TOKEN_PROGRAM_ID,ammId:t.ammId,ammAuthority:r,ammOpenOrders:t.ammOpenOrders,poolCoinTokenAccount:t.poolCoinTokenAccount,poolPcTokenAccount:t.poolPcTokenAccount,serumProgramId:t.serumProgramId,serumMarket:t.serumMarket,serumBids:t.serumMarketKeys.serumBids,serumAsks:t.serumMarketKeys.serumAsks,serumEventQueue:t.serumMarketKeys.serumEventQueue,serumCoinVaultAccount:t.serumMarketKeys.serumCoinVaultAccount,serumPcVaultAccount:t.serumMarketKeys.serumPcVaultAccount,serumVaultSigner:t.serumMarketKeys.serumVaultSigner,userSourceTokenAccount:e,userDestinationTokenAccount:n,userSourceOwner:i}}function mt(t,e,n,r,s,a){const u=(0,m.createProgramAddressSync)([t.address.toBuffer(),t.decoded.vaultSignerNonce.toArrayLike(B,"le",8)],t.programId);return{market:{market:t.address,openOrders:e,requestQueue:t.decoded.requestQueue,eventQueue:t.decoded.eventQueue,bids:t.bidsAddress,asks:t.asksAddress,coinVault:t.decoded.baseVault,pcVault:t.decoded.quoteVault,vaultSigner:u},authority:a,orderPayerTokenAccount:n,coinWallet:r,pcWallet:s,dexProgram:t.programId,tokenProgram:o.TOKEN_PROGRAM_ID,rent:i.SYSVAR_RENT_PUBKEY}}function dt({swapLayout:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o,inAmount:i,minimumOutAmount:r,tokenLedger:s,platformFee:a}){var u;const c=[];for(const m of t.tokenAccounts)c.push({pubkey:m,isSigner:!1,isWritable:!0});return c.push(...Ft(i,s,null===a||void 0===a?void 0:a.feeAccount)),rt.instruction.mercurialExchange(i?new d.BN(i):i,new d.BN(r),null!==(u=null===a||void 0===a?void 0:a.feeBps)&&void 0!==u?u:0,{accounts:ut(t,e,n,o),remainingAccounts:c})}function pt({market:t,sourceMint:e,openOrdersAddress:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:s,minimumOutAmount:a,tokenLedger:u,platformFee:c,referrer:m}){var p;const{side:l,coinWallet:h,pcWallet:g}=e.equals(t.baseMintAddress)?{side:ot.Ask,coinWallet:o,pcWallet:i}:{side:ot.Bid,coinWallet:i,pcWallet:o};let A=Ft(s,u,null===c||void 0===c?void 0:c.feeAccount);return m&&A.push({pubkey:m,isSigner:!1,isWritable:!0}),rt.instruction.serumSwap(l,s?new d.BN(s):s,new d.BN(a),null!==(p=null===c||void 0===c?void 0:c.feeBps)&&void 0!==p?p:0,{accounts:mt(t,n,o,h,g,r),remainingAccounts:A})}function lt({tokenSwapState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:s,minimumOutAmount:a,tokenLedger:u,platformFee:c,isStep:m}){var p;const[l,h]=e.equals(t.mintA)?[t.tokenAccountA,t.tokenAccountB]:[t.tokenAccountB,t.tokenAccountA];return(m?rt.instruction.stepTokenSwap:rt.instruction.tokenSwap)(s?new d.BN(s):s,new d.BN(a),null!==(p=null===c||void 0===c?void 0:c.feeBps)&&void 0!==p?p:0,{accounts:{tokenSwapProgram:t.programId,tokenProgram:o.TOKEN_PROGRAM_ID,swap:t.address,authority:t.authority,userTransferAuthority:r,source:n,swapSource:l,swapDestination:h,destination:i,poolMint:t.poolToken,poolFee:t.feeAccount},remainingAccounts:Ft(s,u,null===c||void 0===c?void 0:c.feeAccount)})}function ht({poolState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:s,minimumOutAmount:a,tokenLedger:u,platformFee:c}){var m;const[p,l]=e.equals(t.token0Mint)?[t.token0Reserves,t.token1Reserves]:[t.token1Reserves,t.token0Reserves],[h,g]=e.equals(t.token0Mint)?[t.token0Fees,t.token1Fees]:[t.token1Fees,t.token0Fees];return rt.instruction.senchaExchange(s?new d.BN(s):s,new d.BN(a),null!==(m=null===c||void 0===c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:t.programId,tokenProgram:o.TOKEN_PROGRAM_ID,swap:t.ammId,userAuthority:r,inputUserAccount:n,inputTokenAccount:p,inputFeesAccount:h,outputUserAccount:i,outputTokenAccount:l,outputFeesAccount:g},remainingAccounts:Ft(s,u,null===c||void 0===c?void 0:c.feeAccount)})}function gt({poolState:t,feeAccount:e,sourceMint:n,userSourceTokenAccount:i,userDestinationTokenAccount:r,userTransferAuthority:s,inAmount:a,minimumOutAmount:u,tokenLedger:c,platformFee:m}){var p;const[l,h]=n.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return rt.instruction.cropperTokenSwap(a?new d.BN(a):a,new d.BN(u),null!==(p=null===m||void 0===m?void 0:m.feeBps)&&void 0!==p?p:0,{accounts:{tokenSwapProgram:t.programId,tokenProgram:o.TOKEN_PROGRAM_ID,swap:t.ammId,swapState:et,authority:t.authority,userTransferAuthority:s,source:i,swapSource:l,swapDestination:h,destination:r,poolMint:t.poolMint,poolFee:e},remainingAccounts:Ft(a,c,null===m||void 0===m?void 0:m.feeAccount)})}function At({raydiumAmm:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:o,inAmount:i,minimumOutAmount:r,tokenLedger:s,platformFee:a}){var u;return rt.instruction.raydiumSwapV2(i?new d.BN(i):i,new d.BN(r),null!==(u=null===a||void 0===a?void 0:a.feeBps)&&void 0!==u?u:0,{accounts:ct(t,e,n,o),remainingAccounts:Ft(i,s,null===a||void 0===a?void 0:a.feeAccount)})}function ft({poolState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:s,minimumOutAmount:a,tokenLedger:u,platformFee:c}){var m;const[p,l,h]=e.equals(t.baseTokenMint)?[ot.Ask,n,i]:[ot.Bid,i,n];return rt.instruction.aldrinSwap(s?new d.BN(s):s,new d.BN(a),p,null!==(m=null===c||void 0===c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:K,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:r,userBaseTokenAccount:l,userQuoteTokenAccount:h,tokenProgram:o.TOKEN_PROGRAM_ID},remainingAccounts:Ft(s,u,null===c||void 0===c?void 0:c.feeAccount)})}function kt({poolState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:i,curve:r,userTransferAuthority:s,inAmount:a,minimumOutAmount:u,tokenLedger:c,platformFee:m}){var p;const[l,h,g]=e.equals(t.baseTokenMint)?[ot.Ask,n,i]:[ot.Bid,i,n];return rt.instruction.aldrinV2Swap(a?new d.BN(a):a,new d.BN(u),l,null!==(p=null===m||void 0===m?void 0:m.feeBps)&&void 0!==p?p:0,{accounts:{swapProgram:q,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:s,userBaseTokenAccount:h,userQuoteTokenAccount:g,curve:r,tokenProgram:o.TOKEN_PROGRAM_ID},remainingAccounts:Ft(a,c,null===m||void 0===m?void 0:m.feeAccount)})}function wt({poolState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:s,minimumOutAmount:a,tokenLedger:u,platformFee:c}){var m;const[p,l]=e.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return rt.instruction.cremaTokenSwap(s?new d.BN(s):s,new d.BN(a),null!==(m=null===c||void 0===c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:t.programId,pool:t.ammId,poolSigner:t.authority,userSourceTokenAccount:n,userDestinationTokenAccount:i,poolSourceTokenAccount:p,poolDestinationTokenAccount:l,poolTicksAccount:t.ticksKey,walletAuthority:r,tokenProgram:o.TOKEN_PROGRAM_ID},remainingAccounts:Ft(s,u,null===c||void 0===c?void 0:c.feeAccount)})}function St(t,e,n,i,r){var s;const a=[];return null!==r&&void 0!==r&&r.feeAccount&&a.push({pubkey:r.feeAccount,isSigner:!1,isWritable:!0}),rt.instruction.riskCheckAndFee(new d.BN(n),null!==(s=null===r||void 0===r?void 0:r.feeBps)&&void 0!==s?s:0,{accounts:{tokenLedger:i,userDestinationTokenAccount:t,userTransferAuthority:e,tokenProgram:o.TOKEN_PROGRAM_ID},remainingAccounts:a})}function yt(t,e){return rt.instruction.setTokenLedger({accounts:{tokenLedger:t,tokenAccount:e}})}function Mt(t,e,n,i,r){const s=e.equals(t.state.tokenA.mint)?t.state.tokenB.adminFeeAccount:t.state.tokenA.adminFeeAccount,[a,u]=e.equals(t.state.tokenA.mint)?[t.state.tokenA.reserve,t.state.tokenB.reserve]:[t.state.tokenB.reserve,t.state.tokenA.reserve];return{swapProgram:t.config.swapProgramID,tokenProgram:o.TOKEN_PROGRAM_ID,swap:t.config.swapAccount,swapAuthority:t.config.authority,userAuthority:r,inputUserAccount:n,inputTokenAccount:a,outputUserAccount:i,outputTokenAccount:u,feesTokenAccount:s}}function Tt({stableSwap:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,inAmount:r,minimumOutAmount:s,tokenLedger:a,platformFee:u}){var c;const m=Ft(r,a,null===u||void 0===u?void 0:u.feeAccount);return rt.instruction.saberSwap(r?new d.BN(r):r,new d.BN(s),null!==(c=null===u||void 0===u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:Mt(t,e,n,o,i),remainingAccounts:m})}function vt({addDecimals:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:i,inAmount:r,minimumOutAmount:s,tokenLedger:a,platformFee:u}){var c;const m=Ft(r,a,null===u||void 0===u?void 0:u.feeAccount);return rt.instruction.saberAddDecimalsDeposit(r?new d.BN(r):r,new d.BN(s),null!==(c=null===u||void 0===u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{addDecimalsProgram:C,wrapper:t.wrapper,wrapperMint:t.mint,wrapperUnderlyingTokens:t.wrapperUnderlyingTokens,owner:i,userUnderlyingTokens:e,userWrappedTokens:n,tokenProgram:o.TOKEN_PROGRAM_ID},remainingAccounts:m})}function Pt({addDecimals:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:i,inAmount:r,minimumOutAmount:s,tokenLedger:a,platformFee:u}){var c;const m=Ft(r,a,null===u||void 0===u?void 0:u.feeAccount);return rt.instruction.saberAddDecimalsWithdraw(r?new d.BN(r):r,new d.BN(s),null!==(c=null===u||void 0===u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{addDecimalsProgram:C,wrapper:t.wrapper,wrapperMint:t.mint,wrapperUnderlyingTokens:t.wrapperUnderlyingTokens,owner:i,userUnderlyingTokens:n,userWrappedTokens:e,tokenProgram:o.TOKEN_PROGRAM_ID},remainingAccounts:m})}function Bt({swapState:t,sourceMint:e,userSourceTokenAccount:n,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:s,minimumOutAmount:a,tokenLedger:u,platformFee:c}){var m;const[p,l]=e.equals(t.tokenAMint)?[t.poolCoinTokenAccount,t.poolPcTokenAccount]:[t.poolPcTokenAccount,t.poolCoinTokenAccount];return rt.instruction.lifinityTokenSwap(s?new d.BN(s):s,new d.BN(a),null!==(m=null===c||void 0===c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:t.programId,authority:t.authority,amm:t.amm,userTransferAuthority:r,sourceInfo:n,destinationInfo:i,swapSource:p,swapDestination:l,poolMint:t.poolMint,feeAccount:t.feeAccount,tokenProgram:o.TOKEN_PROGRAM_ID,pythAccount:t.pythAccount,pythPcAccount:t.pythPcAccount,configAccount:t.configAccount},remainingAccounts:Ft(s,u,null===c||void 0===c?void 0:c.feeAccount)})}function bt({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:i,inAmount:r,minimumOutAmount:s,tokenLedger:a,platformFee:u}){var c;const m=Ft(r,a,null===u||void 0===u?void 0:u.feeAccount);return rt.instruction.cykuraSwap(r?new d.BN(r):r,new d.BN(s),null!==(c=null===u||void 0===u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:G,signer:i,factoryState:z,poolState:t.poolAddress,inputTokenAccount:e,outputTokenAccount:n,inputVault:t.inputVault,outputVault:t.outputVault,lastObservationState:t.lastObservationState,coreProgram:G,tokenProgram:o.TOKEN_PROGRAM_ID},remainingAccounts:m.concat([...t.swapAccountMetas,{pubkey:t.nextObservationState,isSigner:!1,isWritable:!0}])})}function It({additionalArgs:t,userSourceTokenAccount:e,userDestinationTokenAccount:n,userTransferAuthority:i,inAmount:r,minimumOutAmount:s,tokenLedger:a,platformFee:u}){var c;const[m,p]=t.aToB?[e,n]:[n,e];return rt.instruction.whirlpoolSwap(r?new d.BN(r):r,new d.BN(s),t.aToB,null!==(c=null===u||void 0===u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:W,tokenProgram:o.TOKEN_PROGRAM_ID,tokenAuthority:i,whirlpool:t.whirlpool,tokenOwnerAccountA:m,tokenVaultA:t.tokenVaultA,tokenOwnerAccountB:p,tokenVaultB:t.tokenVaultB,tickArray0:t.tickArray0,tickArray1:t.tickArray1,tickArray2:t.tickArray2,oracle:t.oracle},remainingAccounts:Ft(r,a,null===u||void 0===u?void 0:u.feeAccount)})}function Ft(t,e,n){const o=[];return null===t&&o.push({pubkey:e,isSigner:!1,isWritable:!0}),n&&o.push({pubkey:n,isSigner:!1,isWritable:!0}),o}function Dt(){return b.map((t=>{const e={wrapper:new i.PublicKey(t.wrapper),underlying:new i.PublicKey(t.underlying),underlyingDecimals:t.underlyingDecimals,wrapperUnderlyingTokens:new i.PublicKey(t.wrapperUnderlyingTokens),mint:new i.PublicKey(t.mint),decimals:t.decimals};return new Ot(new Nt(e))}))}class Nt{constructor(t){this.addDecimals=void 0,this.addDecimals=t}get multiplier(){return 10**(this.addDecimals.decimals-this.addDecimals.underlyingDecimals)}getOutputAmount(t,e){if(this.addDecimals.mint.equals(e))return this.calculateWithdrawOutputAmount(t);if(this.addDecimals.underlying.equals(e))return this.calculateDepositOutputAmount(t);throw new Error(`unknown input token: ${e.toString()}`)}calculateDepositOutputAmount(t){return u().multiply(u().BigInt(t),u().BigInt(this.multiplier))}calculateWithdrawOutputAmount(t){return u().divide(u().BigInt(t),u().BigInt(this.multiplier))}}class Ot{constructor(t){this.wrappedToken=void 0,this.id=void 0,this.label="Saber (Decimals)",this.shouldPrefetch=!1,this.wrappedToken=t,this.id=this.wrappedToken.addDecimals.wrapper.toBase58()}getAccountsForUpdate(){return new Array}update(t){}getQuote({sourceMint:t,amount:e}){return{notEnoughLiquidity:!1,inAmount:e,outAmount:u().toNumber(this.wrappedToken.getOutputAmount(e,t)),feeAmount:0,feeMint:t.toBase58(),feePct:0,priceImpactPct:0}}createSwapInstructions(t){return this.wrappedToken.addDecimals.underlying.equals(t.sourceMint)?[vt({addDecimals:this.wrappedToken.addDecimals,...t})]:[Pt({addDecimals:this.wrappedToken.addDecimals,...t})]}get reserveTokenMints(){return[this.wrappedToken.addDecimals.underlying,this.wrappedToken.addDecimals.mint]}}function Et(t){return t.reduce(((e,n)=>(t.forEach((t=>{n!==t&&e.push([n,t])})),e)),new Array)}async function Kt(t,e,n=100){return(await Promise.all((o=e,r=n,Array.apply(0,new Array(Math.ceil(o.length/r))).map(((t,e)=>o.slice(e*r,(e+1)*r)))).map((e=>{const n=t._buildArgs([e],t.commitment,"base64");return t._rpcRequest("getMultipleAccounts",n).then((t=>{const e=t.result.value;return e.forEach((t=>{if(t){const e=t;e.data=B.from(t.data[0],t.data[1]),e.owner=new i.PublicKey(e.owner)}})),e})).catch((t=>(console.error("Failed to fetch account infos",t),e.map((()=>null)))))})))).flat();var o,r}const qt=(t,e)=>e.map((e=>{const n=t.get(e.toString());if(!n)throw new Error(`Account info ${e.toBase58()} missing`);return n})),Ct=t=>t.map((t=>u().BigInt(t.amount))),Ut=(0,l.n_)([(0,l._O)("status"),(0,l._O)("nonce"),(0,l._O)("orderNum"),(0,l._O)("depth"),(0,l._O)("coinDecimals"),(0,l._O)("pcDecimals"),(0,l._O)("state"),(0,l._O)("resetFlag"),(0,l._O)("minSize"),(0,l._O)("volMaxCutRatio"),(0,l._O)("amountWaveRatio"),(0,l._O)("coinLotSize"),(0,l._O)("pcLotSize"),(0,l._O)("minPriceMultiplier"),(0,l._O)("maxPriceMultiplier"),(0,l._O)("systemDecimalsValue"),(0,l._O)("minSeparateNumerator"),(0,l._O)("minSeparateDenominator"),(0,l._O)("tradeFeeNumerator"),(0,l._O)("tradeFeeDenominator"),(0,l._O)("pnlNumerator"),(0,l._O)("pnlDenominator"),(0,l._O)("swapFeeNumerator"),(0,l._O)("swapFeeDenominator"),(0,l._O)("needTakePnlCoin"),(0,l._O)("needTakePnlPc"),(0,l._O)("totalPnlPc"),(0,l._O)("totalPnlCoin"),J("poolTotalDepositPc"),J("poolTotalDepositCoin"),J("swapCoinInAmount"),J("swapPcOutAmount"),(0,l._O)("swapCoin2PcFee"),J("swapPcInAmount"),J("swapCoinOutAmount"),(0,l._O)("swapPc2CoinFee"),Y("poolCoinTokenAccount"),Y("poolPcTokenAccount"),Y("coinMintAddress"),Y("pcMintAddress"),Y("lpMintAddress"),Y("ammOpenOrders"),Y("serumMarket"),Y("serumProgramId"),Y("ammTargetOrders"),Y("poolWithdrawQueue"),Y("poolTempLpTokenAccount"),Y("ammOwner"),Y("pnlOwner")]);class Rt{constructor(t,e,n){this.ammId=void 0,this.id=void 0,this.label="Raydium",this.shouldPrefetch=!1,this.coinMint=void 0,this.pcMint=void 0,this.status=void 0,this.serumProgramId=void 0,this.serumMarket=void 0,this.ammOpenOrders=void 0,this.ammTargetOrders=void 0,this.poolCoinTokenAccount=void 0,this.poolPcTokenAccount=void 0,this.serumMarketKeys=void 0,this.coinReserve=void 0,this.pcReserve=void 0,this.feePct=void 0,this.calculator=void 0,this.ammId=t,this.id=t.toBase58();const o=Ut.decode(e.data);this.status=o.status,this.coinMint=new i.PublicKey(o.coinMintAddress),this.pcMint=new i.PublicKey(o.pcMintAddress),this.poolCoinTokenAccount=new i.PublicKey(o.poolCoinTokenAccount),this.poolPcTokenAccount=new i.PublicKey(o.poolPcTokenAccount),this.serumProgramId=new i.PublicKey(o.serumProgramId),this.serumMarket=new i.PublicKey(o.serumMarket),this.ammOpenOrders=new i.PublicKey(o.ammOpenOrders),this.ammTargetOrders=new i.PublicKey(o.ammTargetOrders),this.serumMarketKeys=Object.keys(n).reduce(((t,e)=>{if(!n[e])throw new Error(`Could not find ${e} in params`);return t[e]=new i.PublicKey(n[e]),t}),{});const r=o.swapFeeNumerator,s=o.swapFeeDenominator;this.feePct=new(A())(r.toString()).div(s.toString()),this.calculator=new h.lF(new h.iA(u().BigInt(r),u().BigInt(s)),h.jg)}static decodeSerumMarketKeysString(t,e,n){const o=r.Market.getLayout(t).decode(n.data),i=(0,m.createProgramAddressSync)([e.toBuffer(),o.vaultSignerNonce.toArrayLike(B,"le",8)],t);return{serumBids:o.bids.toBase58(),serumAsks:o.asks.toBase58(),serumEventQueue:o.eventQueue.toBase58(),serumCoinVaultAccount:o.baseVault.toBase58(),serumPcVaultAccount:o.quoteVault.toBase58(),serumVaultSigner:i.toBase58()}}getAccountsForUpdate(){return[this.ammId,this.poolCoinTokenAccount,this.poolPcTokenAccount,this.ammOpenOrders]}update(t){const[e,n,i,s]=qt(t,this.getAccountsForUpdate()),[a,u]=[Rt.tokenAmountAccessor(n),Rt.tokenAmountAccessor(i)],c=r.OpenOrders.fromAccountInfo(this.ammOpenOrders,s,s.owner),m=Ut.decode(e.data);this.coinReserve=a.add(c.baseTokenTotal).sub(new o.u64(String(m.needTakePnlCoin))),this.pcReserve=u.add(c.quoteTokenTotal).sub(new o.u64(String(m.needTakePnlPc)))}static tokenAmountAccessor(t){return o.u64.fromBuffer(t.data.slice(64,72))}getQuote({sourceMint:t,amount:e}){const{coinReserve:n,pcReserve:o}=this;if(!n||!o)throw new Error("Pool token accounts balances not refreshed or empty");const i=this.coinMint.equals(t)?1:0,r=this.calculator.exchange([u().BigInt(n),u().BigInt(o)],u().BigInt(e),i);return{notEnoughLiquidity:!1,inAmount:e,outAmount:u().toNumber(r.expectedOutputAmount),feeAmount:u().toNumber(r.fees),feeMint:t.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:r.priceImpact.toNumber()}}createSwapInstructions(t){return[At({raydiumAmm:this,...t})]}get reserveTokenMints(){return[this.coinMint,this.pcMint]}}const Lt=["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS","5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z","EERNEEnBqdGzBS8dd46wwNY5F2kwnaCQ3vsq2fNKGogZ","8sFf9TW3KzxLiBXcDcjAxqabEsRroo4EiRr3UG1xbJ9m","2iDSTGhjJEiRxNaLF27CY6daMYPs5hgYrP2REHd5YD62"];function xt({market:t,asks:e,bids:n,fromAmount:o,fromMint:i,toMint:r}){const s=Lt.includes(t.address.toBase58())?1e-4:4e-4;return i.equals(t.quoteMintAddress)&&r.equals(t.baseMintAddress)?function(t,e,n,o){let i=u().BigInt(0),r=u().BigInt(0),s=u().BigInt(0),a=u().BigInt(0),c=u().BigInt(0);const m=t.quoteSizeLotsToNumber(new(p())(1));let d=m?u().BigInt(Math.floor(n/(1+o)/m)):h.xE;const l=u().BigInt(t.baseSizeLotsToNumber(new(p())(1)).toString());for(let[p,A]of Vt(e)){u().equal(r,h.xE)&&(r=p),s=p;const t=u().multiply(A,l),e=u().multiply(A,p);if(c=u().add(c,t),u().greaterThanOrEqual(e,d)){const t=u().divide(d,p);a=u().add(a,u().multiply(p,t)),i=u().add(i,u().multiply(l,t)),d=h.xE;break}a=u().add(a,u().multiply(p,A)),i=u().add(i,t),d=u().subtract(d,e)}const g=new(A())(r.toString()),f=new(A())(s.toString()).sub(g).div(g).toNumber(),k=_t(t,new(p())(r.toString())),w=_t(t,new(p())(a.toString()));return{side:"buy",notEnoughLiquidity:u().lessThanOrEqual(c,i),minimum:{in:new(A())(k.toString()).mul(l.toString()).mul(1+o).ceil().toNumber(),out:u().toNumber(l)},inAmount:new(A())(w.toString()).mul(l.toString()).mul(1+o).ceil().toNumber(),outAmount:u().toNumber(i),feeAmount:new(A())(a.toString()).mul(o).toNumber(),priceImpactPct:f,feePct:o}}(t,e,o,s):function(t,e,n,o){let i=u().BigInt(0),r=u().BigInt(0),s=u().BigInt(0),a=u().BigInt(0),c=u().BigInt(n),m=u().BigInt(0);const d=u().BigInt(t.baseSizeLotsToNumber(new(p())(1))),l=u().BigInt(t.quoteSizeLotsToNumber(new(p())(1)));for(const[p,A]of Vt(e)){u().equal(r,h.xE)&&(r=p),s=p;const t=u().multiply(d,A),e=u().multiply(A,u().multiply(p,l));if(a=u().add(a,t),u().greaterThanOrEqual(t,c)){const t=u().divide(c,d),e=u().multiply(t,p);i=u().add(i,u().multiply(e,l)),c=u().subtract(c,e),m=u().add(m,u().multiply(t,d));break}i=u().add(i,e),c=u().subtract(c,t),m=u().add(m,t)}let g=new(A())(i.toString()).mul(1-o).floor().toNumber();const f=_t(t,new(p())(r.toString())),k=_t(t,new(p())(s.toString())),w=f.minus(k).div(f).toNumber();return{side:"sell",notEnoughLiquidity:u().greaterThan(u().BigInt(n),a),minimum:{in:u().toNumber(d),out:f.mul(u().toNumber(d)).mul(1-o).floor().toNumber()},inAmount:u().toNumber(m),outAmount:g,feeAmount:new(A())(u().toNumber(i)).mul(o).round().toNumber(),priceImpactPct:w,feePct:o}}(t,n,o,s)}function*Vt(t){const e=t.isBids;for(const{key:n,quantity:o}of t.slab.items(e)){const t=u().BigInt(n.ushrn(64).toString());yield[t,u().BigInt(o.toString())]}}function _t(t,e){const n=t._decoded.baseLotSize;return n.isZero()?new(A())(0):function(t,e){const n=new(A())(t.div(e).toString()),o=t.umod(e),i=o.gcd(e);return n.add(new(A())(o.div(i).toString()).div(new(A())(e.div(i).toString())))}(e.mul(t._decoded.quoteLotSize).mul(t._baseSplTokenMultiplier),n.mul(t._quoteSplTokenMultiplier))}class Wt{constructor(t){this.market=void 0,this.id=void 0,this.label="Serum",this.shouldPrefetch=!1,this._orderbooks=void 0,this.market=t,this.id=t.address.toBase58()}get orderbooks(){return this._orderbooks}getAccountsForUpdate(){return[this.market.asksAddress,this.market.bidsAddress]}update(t){const[e,n]=qt(t,this.getAccountsForUpdate()),o=r.Orderbook.decode(this.market,e.data),i=r.Orderbook.decode(this.market,n.data);this._orderbooks={asks:o,bids:i}}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(!this.orderbooks)throw new Error("Failed to find orderbooks");const o=xt({market:this.market,asks:this.orderbooks.asks,bids:this.orderbooks.bids,fromMint:t,toMint:e,fromAmount:n});return{notEnoughLiquidity:o.notEnoughLiquidity,minInAmount:o.minimum.in,minOutAmount:o.minimum.out,inAmount:o.inAmount,outAmount:o.outAmount,feeAmount:o.feeAmount,feeMint:this.market.quoteMintAddress.toBase58(),feePct:o.feePct,priceImpactPct:o.priceImpactPct}}createSwapInstructions(t){var e;if(!t.openOrdersAddress)throw new Error("Missing open orders");return[pt({market:this.market,openOrdersAddress:t.openOrdersAddress,referrer:null===t||void 0===t||null===(e=t.quoteMintToReferrer)||void 0===e?void 0:e.get(this.market.quoteMintAddress.toBase58()),...t})]}get reserveTokenMints(){return[this.market.baseMintAddress,this.market.quoteMintAddress]}}Wt.getL2=Vt;class Gt{constructor(t,e,n){this.firstAmm=void 0,this.secondAmm=void 0,this.reserveTokenMints=void 0,this.market=void 0,this.shouldPrefetch=!1,this.portion1=0,this.portion2=0,this.firstAmm=t,this.secondAmm=e,this.reserveTokenMints=n,this.market=t instanceof Wt?t.market:e instanceof Wt?e.market:null}static getAmmIdsFromSplitTradeAmmId(t){const e=t.split("-");return e.length>1?e:[]}static create(t,e){if(!function(t,e){return!(t instanceof Wt&&e instanceof Rt||t instanceof Rt&&e instanceof Wt||t instanceof Wt&&e instanceof Wt)}(t,e))return;const n=Et(t.reserveTokenMints),o=Et(e.reserveTokenMints);for(const i of n)for(const n of o)if(i.every(((t,e)=>t.equals(n[e]))))return new Gt(t,e,i)}setPortions(t,e){if(t+e!==100)throw new Error("Split trade portions must sum to 100");this.portion1=t,this.portion2=e}get id(){return`${this.firstAmm.id}-${this.secondAmm.id}`}get label(){return[{label:this.firstAmm.label,portion:this.portion1},{label:this.secondAmm.label,portion:this.portion2}].sort(((t,e)=>e.portion-t.portion)).map((({label:t,portion:e})=>`${t} (${e}%)`)).join(" + ")}getAccountsForUpdate(){return[]}update(t){}getQuote(t){var e,n,o,i;const r=t.sourceMint.toBase58(),s=t.amount;let a={outAmount:0,portion:0,firstQuote:void 0,secondQuote:void 0};for(let S=100;S-=5;S>0){const e=Math.floor(s*S/100),n=s-e,o=this.firstAmm.getQuote({...t,amount:e}),i=this.secondAmm.getQuote({...t,amount:n}),r=o.outAmount+i.outAmount;if(r<a.outAmount)break;a={outAmount:r,portion:S,firstQuote:o,secondQuote:i}}if(!a.firstQuote||!a.secondQuote)throw new Error("Unreachable: There was no better solution than getting 0 outAmount");const{outAmount:u,portion:c,firstQuote:m,secondQuote:d}=a,p=c,l=100-p;this.portion1=p,this.portion2=l;let h={amount:m.feeAmount,mint:m.feeMint},g={amount:d.feeAmount,mint:d.feeMint};h.mint!==g.mint&&(h.mint!==r&&(h={amount:Math.floor(h.amount*s*p/100/a.outAmount),mint:r}),g.mint!==r&&(g={amount:Math.floor(g.amount*s*l/100/a.outAmount),mint:r}));const A=(p*m.feePct+l*d.feePct)/100,f=(p*m.priceImpactPct+l*d.priceImpactPct)/100,k=m.minInAmount||d.minInAmount?(null!==(e=m.minInAmount)&&void 0!==e?e:0)+(null!==(n=d.minInAmount)&&void 0!==n?n:0):void 0,w=m.minOutAmount||d.minOutAmount?(null!==(o=m.minOutAmount)&&void 0!==o?o:0)+(null!==(i=d.minOutAmount)&&void 0!==i?i:0):void 0;return{notEnoughLiquidity:!1,inAmount:t.amount,outAmount:u,minInAmount:k,minOutAmount:w,feeAmount:h.amount+g.amount,feeMint:h.mint,feePct:A,priceImpactPct:f}}createSwapInstructions(t){const e=t.inAmount;if(null===e)throw new Error("Split trade cannot be used with a null inAmount");const n=Math.floor(e*this.portion1/100),o=e-n;return[...this.firstAmm.createSwapInstructions({...t,inAmount:n,minimumOutAmount:0,platformFee:void 0}),...this.secondAmm.createSwapInstructions({...t,inAmount:o,minimumOutAmount:0,platformFee:void 0}),St(t.userDestinationTokenAccount,t.userTransferAuthority,t.minimumOutAmount,t.tokenLedger,t.platformFee)]}}const zt=(t,e)=>t.id!==e.id&&(!(t instanceof Ot&&e instanceof Ot)&&!(t instanceof Gt||e instanceof Gt));class Qt{constructor(t){this.stableSwap=void 0,this.id=void 0,this.label="Saber",this.shouldPrefetch=!1,this.tokenAccounts=[],this.calculator=void 0,this.stableSwap=t,this.id=t.config.swapAccount.toBase58(),this.calculator=new h.IB(h.gE,(0,s.sh)(this.stableSwap.state),[h.ry,h.ry],new h.iA(this.stableSwap.state.fees.trade.numerator,this.stableSwap.state.fees.trade.denominator))}getAccountsForUpdate(){return[this.stableSwap.state.tokenA.reserve,this.stableSwap.state.tokenB.reserve]}update(t){let e=qt(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=(0,w.nt)(t.data);if(!e)throw new Error("Invalid token account data");return e}))}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const o=new(A())(this.stableSwap.state.fees.trade.asFraction.toFixed(4)),[i,r]=this.tokenAccounts[0].mint.equals(t)?[0,1]:[1,0];this.calculator.setAmp((0,s.sh)(this.stableSwap.state));const a=this.calculator.exchange(Ct(this.tokenAccounts),u().BigInt(n),i,r);return{notEnoughLiquidity:!1,inAmount:n,outAmount:u().toNumber(a.expectedOutputAmount),feeAmount:u().toNumber(a.fees),feeMint:e.toBase58(),feePct:o.toNumber(),priceImpactPct:a.priceImpact.toNumber()}}createSwapInstructions(t){return[Tt({stableSwap:this.stableSwap,...t})]}get reserveTokenMints(){return[this.stableSwap.state.tokenA.mint,this.stableSwap.state.tokenB.mint]}}const Ht=new o.u64(0);class jt{constructor(t,e){this.numerator=void 0,this.denominator=void 0,this.toString=()=>`${this.numerator.toString()}/${this.denominator.toString()}`,this.numerator=t,this.denominator=e}static fromDecimal(t){return jt.fromFraction(t.toDecimalPlaces(1).mul(10).toNumber(),1e3)}static fromFraction(t,e){const n="number"===typeof t?new o.u64(t.toString()):t,i="number"===typeof e?new o.u64(e.toString()):e;return new jt(n,i)}toDecimal(){return this.denominator.eq(Ht)?new(A())(0):new(A())(this.numerator.toString()).div(new(A())(this.denominator.toString()))}add(t){const e=this.denominator.gcd(t.denominator),n=this.denominator.div(e).mul(t.denominator),i=n.div(this.denominator),r=n.div(t.denominator),s=this.numerator.mul(i),a=t.numerator.mul(r),u=s.add(a);return new jt(new o.u64(u.toString()),new o.u64(n.toString()))}}const Yt=(0,l.n_)([Z("tradeFeeNumerator"),Z("tradeFeeDenominator"),Z("ownerTradeFeeNumerator"),Z("ownerTradeFeeDenominator"),Z("ownerWithdrawFeeNumerator"),Z("ownerWithdrawFeeDenominator")],"fees"),Xt=[(0,l.Ik)(8,"padding"),Y("lpTokenFreezeVault"),Y("poolMint"),Y("baseTokenVault"),Y("baseTokenMint"),Y("quoteTokenVault"),Y("quoteTokenMint"),Y("poolSigner"),(0,l.u8)("poolSignerNonce"),Y("authority"),Y("initializerAccount"),Y("feeBaseAccount"),Y("feeQuoteAccount"),Y("feePoolTokenAccount"),Yt],Zt=(0,l.n_)(Xt),Jt=(0,l.n_)([...Xt,(0,l.u8)("curveType"),Y("curve")]),$t=(0,l.n_)([(0,l.Ik)(8,"padding"),Z("amp")]);function te(t,e){const n=!!e.owner.equals(q),o=(n?Jt:Zt).decode(e.data),i="curveType"in o?{curveType:o.curveType,curve:o.curve}:{};return{isV2:n,address:t,poolMint:o.poolMint,baseTokenVault:o.baseTokenVault,baseTokenMint:o.baseTokenMint,quoteTokenVault:o.quoteTokenVault,quoteTokenMint:o.quoteTokenMint,poolSigner:o.poolSigner,feeBaseAccount:o.feeBaseAccount,feeQuoteAccount:o.feeQuoteAccount,feePoolTokenAccount:o.feePoolTokenAccount,fees:{traderFee:jt.fromFraction(o.fees.tradeFeeNumerator,o.fees.tradeFeeDenominator),ownerFee:jt.fromFraction(o.fees.ownerTradeFeeNumerator,o.fees.ownerTradeFeeDenominator)},...i}}class ee{constructor(t,e,n){if(this.params=void 0,this.id=void 0,this.label="Aldrin",this.shouldPrefetch=!1,this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.poolState=te(t,e),this.id=t.toBase58(),1===this.poolState.curveType){const{amp:t}=this.params;if(!t)throw new Error("Amp is required for a stable curve");this.calculator=new h._J(u().BigInt(t),new h.iA(u().BigInt(this.poolState.fees.traderFee.numerator.toString()),u().BigInt(this.poolState.fees.traderFee.denominator.toString())),new h.iA(u().BigInt(this.poolState.fees.ownerFee.numerator.toString()),u().BigInt(this.poolState.fees.ownerFee.denominator.toString())))}else this.calculator=new h.lF(new h.iA(u().BigInt(this.poolState.fees.traderFee.numerator.toString()),u().BigInt(this.poolState.fees.traderFee.denominator.toString())),new h.iA(u().BigInt(this.poolState.fees.ownerFee.numerator.toString()),u().BigInt(this.poolState.fees.ownerFee.denominator.toString())))}static decodeStableCurveAmp(t){const{amp:e}=$t.decode(t.data);return 2*e.toNumber()}getAccountsForUpdate(){return[this.poolState.quoteTokenVault,this.poolState.baseTokenVault]}update(t){const e=qt(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=(0,w.nt)(t.data);if(!e)throw new Error("Invalid token account");return e}))}getQuote({sourceMint:t,amount:e}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");let n=new(A())(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new(A())(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));const o=this.tokenAccounts[0].mint.equals(t)?1:0;let i=this.calculator.exchange(Ct(this.tokenAccounts),u().BigInt(e),o);return{notEnoughLiquidity:!1,inAmount:e,outAmount:u().toNumber(i.expectedOutputAmount),feeAmount:u().toNumber(i.fees),feeMint:t.toBase58(),feePct:n.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}createSwapInstructions(t){if(this.poolState.isV2){if(!this.poolState.curve)throw new Error("Unable to fetch curve account.");const e=this.poolState.curve;return[kt({poolState:this.poolState,curve:e,...t})]}return[ft({poolState:this.poolState,...t})]}get reserveTokenMints(){return[this.poolState.baseTokenMint,this.poolState.quoteTokenMint]}}ee.accountInfoToAldrinPoolState=te;const ne=new i.PublicKey("SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1"),oe=new Map([["9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP","Orca"],[ne.toBase58(),"Step"],["PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP","Penguin"],["SSwapUtytfBdBn1b9NUGG6foMVPtcWgpRU32HToDUZr","Saros"]]),ie=(0,l.n_)([(0,l.u8)("version"),(0,l.u8)("isInitialized"),(0,l.u8)("bumpSeed"),Y("tokenProgramId"),Y("tokenAccountA"),Y("tokenAccountB"),Y("tokenPool"),Y("mintA"),Y("mintB"),Y("feeAccount"),Z("tradeFeeNumerator"),Z("tradeFeeDenominator"),Z("ownerTradeFeeNumerator"),Z("ownerTradeFeeDenominator"),Z("ownerWithdrawFeeNumerator"),Z("ownerWithdrawFeeDenominator"),Z("hostFeeNumerator"),Z("hostFeeDenominator"),(0,l.u8)("curveType"),(0,l.Ik)(32,"curveParameters")]),re=(0,l.n_)([(0,l.u8)("version"),(0,l.u8)("isInitialized"),(0,l.u8)("bumpSeed"),Y("tokenProgramId"),Y("tokenAccountA"),Y("tokenAccountB"),Y("tokenPool"),Y("mintA"),Y("mintB"),Y("feeAccount"),Z("tradeFeeNumerator"),Z("tradeFeeDenominator"),Z("ownerTradeFeeNumerator"),Z("ownerTradeFeeDenominator"),Z("ownerWithdrawFeeNumerator"),Z("ownerWithdrawFeeDenominator"),(0,l.u8)("curveType"),(0,l.Ik)(32,"curveParameters"),(0,l.u8)("poolNonce")]);var se;!function(t){t[t.ConstantProduct=0]="ConstantProduct",t[t.Stable=2]="Stable"}(se||(se={}));class ae{constructor(t,e,n){if(this.label=void 0,this.id=void 0,this.shouldPrefetch=!1,this.tokenSwapState=void 0,this.curveType=void 0,this.tokenAccounts=[],this.calculator=void 0,this.label=n,this.id=t.toBase58(),this.tokenSwapState=function(t,e){const n=e.owner,o=n.equals(ne)?re.decode(e.data):ie.decode(e.data);if(!o.isInitialized)throw new Error("Invalid token swap state");const[r]=(0,m.findProgramAddressSync)([t.toBuffer()],n),s=new i.PublicKey(o.tokenPool),a=new i.PublicKey(o.feeAccount),u=new i.PublicKey(o.tokenAccountA),c=new i.PublicKey(o.tokenAccountB),d=new i.PublicKey(o.mintA),p=new i.PublicKey(o.mintB);return{address:t,programId:n,tokenProgramId:new i.PublicKey(o.tokenProgramId),poolToken:s,feeAccount:a,authority:r,tokenAccountA:u,tokenAccountB:c,mintA:d,mintB:p,tradeFeeNumerator:o.tradeFeeNumerator,tradeFeeDenominator:o.tradeFeeDenominator,ownerTradeFeeNumerator:o.ownerTradeFeeNumerator,ownerTradeFeeDenominator:o.ownerTradeFeeDenominator,ownerWithdrawFeeNumerator:o.ownerWithdrawFeeNumerator,ownerWithdrawFeeDenominator:o.ownerWithdrawFeeDenominator,curveType:o.curveType,curveParameters:o.curveParameters,poolNonce:"poolNonce"in o?o.poolNonce:void 0}}(t,e),this.curveType=this.tokenSwapState.curveType,!(this.curveType in se))throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);this.tokenSwapState.curveType===se.ConstantProduct?this.calculator=new h.lF(new h.iA(u().BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),u().BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new h.iA(u().BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),u().BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString()))):this.calculator=new h._J(u().BigInt(this.tokenSwapState.curveParameters[0]),new h.iA(u().BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),u().BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new h.iA(u().BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),u().BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString())))}getAccountsForUpdate(){return[this.tokenSwapState.tokenAccountA,this.tokenSwapState.tokenAccountB]}update(t){const e=qt(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=(0,w.nt)(t.data);if(!e)throw new Error("Invalid token account");return e}))}getQuote({sourceMint:t,amount:e}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");let n=new(A())(this.tokenSwapState.tradeFeeNumerator.toString()).div(this.tokenSwapState.tradeFeeDenominator.toString()).add(new(A())(this.tokenSwapState.ownerTradeFeeNumerator.toString()).div(this.tokenSwapState.ownerTradeFeeDenominator.toString()));const o=this.tokenAccounts[0].mint.equals(t)?1:0;let i=this.calculator.exchange(Ct(this.tokenAccounts),u().BigInt(Math.floor(e)),o);return{notEnoughLiquidity:!1,inAmount:e,outAmount:u().toNumber(i.expectedOutputAmount),feeAmount:u().toNumber(i.fees),feeMint:t.toBase58(),feePct:n.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}createSwapInstructions(t){return[lt({tokenSwapState:this.tokenSwapState,...t,isStep:this.tokenSwapState.programId.equals(ne)})]}get reserveTokenMints(){return[this.tokenSwapState.mintA,this.tokenSwapState.mintB]}}const ue=Math.pow(10,10),ce=(0,l.n_)([(0,l.u8)("version"),(0,l.u8)("isInitialized"),(0,l.u8)("nonce"),Z("amplificationCoefficient"),Z("feeNumerator"),Z("adminFeeNumerator"),(0,l.Jq)("tokenAccountsLength"),Z("precisionFactor"),Z("precisionMultiplierA"),Z("precisionMultiplierB"),Z("precisionMultiplierC"),Z("precisionMultiplierD"),Y("tokenAccountA"),Y("tokenAccountB"),Y("tokenAccountC"),Y("tokenAccountD")]),me=(t,e)=>{const n=e.owner,o=ce.decode(e.data),i=o.tokenAccountsLength,[r]=(0,m.findProgramAddressSync)([t.toBuffer()],n),s=[o.precisionMultiplierA.toNumber(),o.precisionMultiplierB.toNumber(),o.precisionMultiplierC.toNumber(),o.precisionMultiplierD.toNumber()].slice(0,i),a=[o.tokenAccountA,o.tokenAccountB,o.tokenAccountC,o.tokenAccountD].slice(0,i);return{programId:n,authority:r,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:t,amplificationCoefficient:o.amplificationCoefficient.toNumber(),feeNumerator:o.feeNumerator.toNumber(),tokenAccountsLength:i,precisionFactor:o.precisionFactor.toNumber(),precisionMultipliers:s,tokenAccounts:a}};class de{constructor(t,e,n){this.params=void 0,this.id=void 0,this.label="Mercurial",this.shouldPrefetch=!1,this.swapLayout=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.id=t.toBase58(),this.swapLayout=me(t,e),this.calculator=new h.IB(u().BigInt(this.swapLayout.tokenAccountsLength),u().BigInt(this.swapLayout.amplificationCoefficient),this.swapLayout.precisionMultipliers.map((t=>u().BigInt(t))),new h.iA(u().BigInt(this.swapLayout.feeNumerator),u().BigInt(ue)))}getAccountsForUpdate(){return this.swapLayout.tokenAccounts}update(t){let e=qt(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>(0,w.nt)(t.data))).filter((t=>null!==t))}getQuote({sourceMint:t,destinationMint:e,amount:n}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const o=this.tokenAccounts.findIndex((e=>e.mint.equals(t))),i=this.tokenAccounts.findIndex((t=>t.mint.equals(e))),r=this.calculator.exchange(Ct(this.tokenAccounts),u().BigInt(n),o,i),s=this.swapLayout.feeNumerator/ue;return{notEnoughLiquidity:!1,inAmount:n,outAmount:u().toNumber(r.expectedOutputAmount),feeAmount:u().toNumber(r.fees),feeMint:e.toBase58(),feePct:s,priceImpactPct:r.priceImpact.toNumber()}}createSwapInstructions(t){return[dt({swapLayout:this.swapLayout,...t})]}get reserveTokenMints(){return this.params.tokenMints.map((t=>new i.PublicKey(t)))}}de.decodeSwapLayout=me;class pe{static async getStateFromStateAccount(t){const e=await t.getAccountInfo(et);if(!e)throw new Error("State account not found");return(t=>{const e=tt.decode(t.data);return{isInitialized:Boolean(e.isInitialized),stateOwner:e.stateOwner,feeOwner:e.feeOwner,initialSupply:e.initialSupply,returnFeeNumerator:e.returnFeeNumerator.toNumber(),fixedFeeNumerator:e.fixedFeeNumerator.toNumber(),feeDenominator:e.feeDenominator.toNumber(),curveType:e.curveType,curveParameters:e.curveParameters}})(e)}constructor(t,e,n){this.params=void 0,this.id=void 0,this.label="Cropper",this.shouldPrefetch=!1,this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.feePct=void 0,this.params=n,this.id=t.toBase58(),this.poolState=nt(t,e),this.feePct=new(A())(this.params.fixedFeeNumerator).div(this.params.feeDenominator).add(new(A())(this.params.returnFeeNumerator).div(this.params.feeDenominator)),this.params.tokenAFeeAccount=new i.PublicKey(this.params.tokenAFeeAccount),this.params.tokenBFeeAccount=new i.PublicKey(this.params.tokenBFeeAccount),this.calculator=new h.lF(new h.iA(u().BigInt(this.params.fixedFeeNumerator),u().BigInt(this.params.feeDenominator)),new h.iA(u().BigInt(this.params.returnFeeNumerator),u().BigInt(this.params.feeDenominator)))}getAccountsForUpdate(){return[this.poolState.tokenAAccount,this.poolState.tokenBAccount]}update(t){const e=qt(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=(0,w.nt)(t.data);if(!e)throw new Error("Invalid token account");return e}))}getQuote({sourceMint:t,amount:e}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const n=this.tokenAccounts[0].mint.equals(t)?1:0,o=this.calculator.exchange(Ct(this.tokenAccounts),u().BigInt(e),n);return{notEnoughLiquidity:!1,inAmount:e,outAmount:u().toNumber(o.expectedOutputAmount),feeAmount:u().toNumber(o.fees),feeMint:t.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}createSwapInstructions(t){const e=t.sourceMint.equals(this.poolState.mintA)?this.params.tokenAFeeAccount:this.params.tokenBFeeAccount;return[gt({poolState:this.poolState,feeAccount:e,...t})]}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}pe.decodePoolState=nt;const le=(t,e)=>{const n=e.owner,o=S.km.decode(e.data),[i]=(0,m.findProgramAddressSync)([t.toBuffer()],n);return{programId:n,authority:i,version:o.version,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:t,tokenProgramId:o.tokenProgramId,tokenAAccount:o.swapTokenA,tokenBAccount:o.swapTokenB,ticksKey:o.ticksKey,mintA:o.tokenAMint,mintB:o.tokenBMint,fee:o.fee,currentSqrtPrice:o.currentSqrtPrice,currentLiquity:o.currentLiquity}};class he{constructor(t,e){this.id=void 0,this.label="Crema",this.shouldPrefetch=!1,this.ticks=void 0,this.poolState=void 0,this.poolState=le(t,e),this.id=t.toBase58()}getAccountsForUpdate(){return[this.poolState.ammId,this.poolState.ticksKey]}update(t){const[e,n]=qt(t,this.getAccountsForUpdate());this.poolState=le(this.poolState.ammId,e);const o=(0,S.YD)(this.poolState.ticksKey,n);if(!o)throw new Error(`Ticks account invalid: ${this.poolState.ticksKey.toBase58()}`);this.ticks=o.data.ticks}getQuote({sourceMint:t,amount:e}){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");if(0===e)return{notEnoughLiquidity:!1,inAmount:e,outAmount:0,feeAmount:0,feeMint:t.toBase58(),feePct:this.poolState.fee.toNumber(),priceImpactPct:0};const n=this.poolState.mintA.equals(t)?this.preSwapA(new(A())(e)):this.preSwapB(new(A())(e));return{notEnoughLiquidity:!1,inAmount:e,outAmount:n.amountOut.toNumber(),feeAmount:n.feeUsed.toNumber(),feeMint:t.toBase58(),feePct:this.poolState.fee.toNumber(),priceImpactPct:n.impact.toNumber()}}preSwapA(t){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");let e=(0,S.mz)(this.ticks,this.poolState.currentSqrtPrice,this.poolState.fee,this.poolState.currentLiquity,t),n=this.poolState.currentSqrtPrice.pow(2),o=e.amountOut.div(e.amountUsed).sub(n).div(n).abs();return{...e,impact:o}}preSwapB(t){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");let e=(0,S.Go)(this.ticks,this.poolState.currentSqrtPrice,this.poolState.fee,this.poolState.currentLiquity,t),n=this.poolState.currentSqrtPrice.pow(2),o=new(A())(1).div(n),i=e.amountOut.div(e.amountUsed).sub(o).div(o).abs();return{...e,impact:i}}createSwapInstructions(t){return[wt({poolState:this.poolState,...t})]}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}const ge=(0,l.n_)([(0,l.Ik)(8,"discriminator"),Y("factory"),(0,l.u8)("bump"),Z("index"),Y("admin"),Y("token0Reserves"),Y("token0Mint"),Y("token0Fees"),Y("token1Reserves"),Y("token1Mint"),Y("token1Fees"),(0,l.u8)("isPaused"),Y("poolMint"),Z("tradeFeeKbps"),Z("withdrawFeeKbps"),Z("adminTradeFeeKbps"),Z("adminWithdrawFeeKbps")]);class Ae{constructor(t,e){this.id=void 0,this.label="Sencha",this.shouldPrefetch=!1,this.poolState=void 0,this.calculator=void 0,this.tokenAccounts=[],this.id=t.toBase58(),this.poolState=((t,e)=>{const n=e.owner,o=ge.decode(e.data);return{programId:n,isPaused:Boolean(o.isPaused),bump:o.bump,ammId:t,token0Reserves:o.token0Reserves,token1Reserves:o.token1Reserves,token0Mint:o.token0Mint,token1Mint:o.token1Mint,token0Fees:o.token0Fees,token1Fees:o.token1Fees,poolMint:o.poolMint,tradeFeeKbps:o.tradeFeeKbps.toNumber()}})(t,e),this.calculator=new h.lF(new h.iA(u().BigInt(this.poolState.tradeFeeKbps),u().BigInt(1e7)),new h.iA(h.xE,h.xE),!1)}get isPaused(){return this.poolState.isPaused}getAccountsForUpdate(){return[this.poolState.token0Reserves,this.poolState.token1Reserves]}update(t){const e=qt(t,this.getAccountsForUpdate());this.tokenAccounts=e.map((t=>{const e=(0,w.nt)(t.data);if(!e)throw new Error("Invalid token account");return e}))}getQuote({sourceMint:t,amount:e}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const n=this.tokenAccounts[0].mint.equals(t)?1:0;let o=this.calculator.exchange(Ct(this.tokenAccounts),u().BigInt(e),n),i=this.poolState.tradeFeeKbps/1e7;return{notEnoughLiquidity:!1,inAmount:e,outAmount:u().toNumber(o.expectedOutputAmount),feeAmount:u().toNumber(o.fees),feeMint:t.toBase58(),feePct:i,priceImpactPct:o.priceImpact.toNumber()}}createSwapInstructions(t){return[ht({poolState:this.poolState,...t})]}get reserveTokenMints(){return[this.poolState.token0Mint,this.poolState.token1Mint]}}class fe{constructor(t,e){var n;this.ammAccountInfo=void 0,this.id=void 0,this.label="Lifinity",this.shouldPrefetch=!1,this.swapState=void 0,this.poolInfo=void 0,this.accountInfos=[],this.ammAccountInfo=e,this.id=t.toBase58(),this.swapState=((t,e)=>{const n=e.owner,o=y.Yk.decode(e.data),[i]=(0,m.findProgramAddressSync)([t.toBuffer()],n);return{programId:n,authority:i,amm:t,tokenAMint:o.tokenAMint,tokenBMint:o.tokenBMint,poolMint:o.poolMint,feeAccount:o.poolFeeAccount,pythAccount:o.pythAccount,pythPcAccount:o.pythPcAccount,configAccount:o.configAccount,poolCoinTokenAccount:o.tokenAAccount,poolCoinMint:o.tokenAMint,poolPcTokenAccount:o.tokenBAccount,poolPcMint:o.tokenBMint}})(t,e),this.poolInfo={amm:(n=this.swapState).amm.toBase58(),configAccount:n.configAccount.toBase58(),feeAccount:n.feeAccount.toBase58(),pythAccount:n.pythAccount.toBase58(),pythPcAccount:n.pythPcAccount.toBase58(),poolCoinMint:n.poolCoinMint.toBase58(),poolCoinTokenAccount:n.poolCoinTokenAccount.toBase58(),poolMint:n.poolMint.toBase58(),poolCoinDecimal:0,poolPcDecimal:0,poolPcTokenAccount:n.poolPcTokenAccount.toBase58(),poolPcMint:n.poolPcMint.toBase58()}}getAccountsForUpdate(){return[this.swapState.poolCoinTokenAccount,this.swapState.poolPcTokenAccount,this.swapState.configAccount,this.swapState.pythAccount,this.swapState.pythPcAccount]}update(t){this.getAccountsForUpdate().forEach(((e,n)=>{const o=t.get(e.toBase58());o&&(this.accountInfos[n]={publicKey:e,account:o})}))}getQuote({sourceMint:t,amount:e}){if(this.accountInfos.length!==this.getAccountsForUpdate().length)throw new Error("Accounts not loaded");const n=this.swapState.poolCoinMint.equals(t)?y.vS.AtoB:y.vS.BtoA,{amm:o,pyth:i,pythPc:r,fees:s,coinBalance:a,pcBalance:u,config:c}=(0,y._l)([{publicKey:this.swapState.amm,account:this.ammAccountInfo},...this.accountInfos],this.poolInfo);if(!i.status.equals(1)||r&&!r.status.equals(1))throw new Error("Pyth accounts are outdated");const m=new(A())(e),d=(0,y.gx)(m,i.publishSlot.toNumber(),o,s,a,u,c,i,r,n);return{notEnoughLiquidity:!1,inAmount:e,outAmount:d.amountSwapped.toNumber(),feeAmount:d.fee.toNumber(),feeMint:t.toBase58(),feePct:d.feePercent.toNumber(),priceImpactPct:d.priceImpact.toNumber()}}createSwapInstructions(t){return[Bt({swapState:this.swapState,...t})]}get reserveTokenMints(){return[this.swapState.poolCoinMint,this.swapState.poolPcMint]}}function ke(t,e){const n=(0,M.fB)(e);if(!n)throw new Error(`Failed to parse whilpool ${t.toBase58()}`);return n}class we{constructor(t,e){this.address=void 0,this.id=void 0,this.label="Orca (Whirlpools)",this.shouldPrefetch=!0,this.whirlpoolData=void 0,this.tickArrays=new Map,this.tickPks=void 0,this.oracle=void 0,this.feePct=void 0,this.address=t,this.id=t.toBase58(),this.whirlpoolData=ke(t,e.data),this.oracle=(0,m.findProgramAddressSync)([B.from("oracle"),t.toBuffer()],W)[0],this.feePct=new(A())(this.whirlpoolData.feeRate).div(1e6).toNumber(),this.tickPks=(0,M.rz)(t,this.whirlpoolData)}getAccountsForUpdate(){return[this.address,...this.tickPks]}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Missing ${this.address.toBase58()}`);this.whirlpoolData=ke(this.address,e.data),this.tickPks=(0,M.rz)(this.address,this.whirlpoolData),this.tickArrays.clear();for(const n of this.tickPks){const e=n.toBase58(),o=t.get(e);if(!o)continue;const i=(0,M.pb)(o.data);if(!i)throw new Error(`Could not parse tick array ${e}`);this.tickArrays.set(e,i)}}getQuote({sourceMint:t,amount:e}){const n=(0,M.m9)({poolAddress:this.address,whirlpool:this.whirlpoolData,tickArrays:this.tickArrays,tokenMint:t,tokenAmount:new(p())(e.toString()),isInput:!0}),o=Number(n.amountIn.toString()),i=Math.floor(this.feePct*o),r=n.aToB?new(A())(n.amountOut.toString()).div(n.amountIn.toString()):new(A())(n.amountIn.toString()).div(n.amountOut.toString()),s=(a=this.whirlpoolData.sqrtPrice,new(A())(a.toString()).mul(A().pow(2,-64))).pow(2);var a;const u=s.minus(r).div(s).abs().toNumber();return{notEnoughLiquidity:!1,inAmount:o,outAmount:Number(n.amountOut.toString()),feeAmount:i,feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:Number(u)}}createSwapInstructions(t){const e=t.sourceMint.equals(this.whirlpoolData.tokenMintA),[n,o,i]=(0,M.AR)(this.whirlpoolData.tickCurrentIndex,this.whirlpoolData.sqrtPrice,this.whirlpoolData.tickSpacing,this.address,this.tickArrays,W,e);return[It({additionalArgs:{aToB:e,whirlpool:this.address,tickArray0:n,tickArray1:o,tickArray2:i,oracle:this.oracle,...this.whirlpoolData},...t})]}get reserveTokenMints(){return[this.whirlpoolData.tokenMintA,this.whirlpoolData.tokenMintB]}}class Se{constructor(t,e){this.program=void 0,this.pool=void 0,this.bitmapCache=void 0,this.tickCache=void 0,this.accountsToFetch={bitmaps:[],ticks:[]},this.program=t,this.pool=e,this.bitmapCache=new Map,this.tickCache=new Map}async eagerLoadCache(t,e){const n=u().toNumber(u().divide(u().BigInt(t),u().BigInt(e))),{wordPos:o}=(0,T.tickPosition)(n);try{const t=[],{wordPos:n}=(0,T.tickPosition)(Math.floor(T.TickMath.MIN_TICK/e)),{wordPos:r}=(0,T.tickPosition)(Math.floor(T.TickMath.MAX_TICK/e)),s=Math.max(o-10,n),a=Math.min(o+10,r);for(let e=s;e<a;e++)t.push(this.getBitmapAddressSync(e));const m=await this.program.account.tickBitmapState.fetchMultiple(t),d=[];for(let o=0;o<a-s;o++){var i;const n=o+s,r=null===(i=m[o])||void 0===i?void 0:i.word,a=r?(0,T.generateBitmapWord)(r):new c.BN(0);if(this.bitmapCache.set(n,{address:t[o],word:a}),a&&!a.eqn(0))for(let t=0;t<256;t++)if(a.shrn(t).and(new c.BN(1)).eqn(1)){const o=((n<<8)+t)*e,i=this.getTickAddressSync(o);d.push(i)}}const p=await this.program.account.tickState.fetchMultiple(d);for(const e in d){const t=p[e];if(!t)continue;const{tick:n,liquidityNet:o}=t;this.tickCache.set(n,{address:d[e],liquidityNet:u().BigInt(o)})}}catch(r){console.log(r)}}lazyLoadAccountsToCache(t,e){const n=u().toNumber(u().divide(u().BigInt(t),u().BigInt(e))),{wordPos:o}=(0,T.tickPosition)(n),i=[],r=[],{wordPos:s}=(0,T.tickPosition)(Math.floor(T.TickMath.MIN_TICK/e)),{wordPos:a}=(0,T.tickPosition)(Math.floor(T.TickMath.MAX_TICK/e)),m=Math.max(o-10,s),d=Math.min(o+10,a);for(let u=m;u<d;u++){i.push(this.getBitmapAddressSync(u));const t=this.bitmapCache.get(u);r.push(t)}const p=[];for(let u=0;u<d-m;u++){var l,h;const t=u+m,n=null!==(l=null===(h=r[u])||void 0===h?void 0:h.word)&&void 0!==l?l:new c.BN(0);if(this.bitmapCache.set(t,{address:i[u],word:n}),n&&!n.eqn(0))for(let o=0;o<256;o++)if(n.shrn(o).and(new c.BN(1)).eqn(1)){const n=((t<<8)+o)*e,i=this.getTickAddressSync(n);p.push(i)}}return this.accountsToFetch={bitmaps:i,ticks:p},[...i,...p]}getTick(t){let e=this.tickCache.get(t);if(!e)throw new Error("Tick not cached");return{address:e.address,liquidityNet:e.liquidityNet}}async getTickAddress(t){return this.getTickAddressSync(t)}getTickAddressSync(t){return(0,m.findProgramAddressSync)([T.TICK_SEED,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),(0,T.u32ToSeed)(this.pool.fee),(0,T.u32ToSeed)(t)],this.program.programId)[0]}async getBitmapAddress(t){return this.getBitmapAddressSync(t)}getBitmapAddressSync(t){return(0,m.findProgramAddressSync)([T.BITMAP_SEED,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),(0,T.u32ToSeed)(this.pool.fee),(0,T.u16ToSeed)(t)],this.program.programId)[0]}getBitmap(t){let e=this.bitmapCache.get(t);if(!e)throw new Error("Bitmap not cached");return e}nextInitializedTickWithinOneWord(t,e,n){let o=u().toNumber(u().divide(u().BigInt(t),u().BigInt(n)));t<0&&t%n!==0&&(o-=1),e||(o+=1);const{wordPos:i,bitPos:r}=(0,T.tickPosition)(o),s=this.getBitmap(i),{next:a,initialized:c}=(0,T.nextInitializedBit)(s.word,r,e);return[(0,T.buildTick)(i,a,n),c,i,r,s.address]}updateCachedAccountInfos(t){for(const e of this.accountsToFetch.bitmaps){const n=t.get(e.toBase58());if(n){const t=this.program.coder.accounts.decode("tickBitmapState",n.data);this.bitmapCache.set(t.wordPos,{address:e,word:(0,T.generateBitmapWord)(t.word)})}}for(const e of this.accountsToFetch.ticks){const n=t.get(e.toBase58());if(n){const t=this.program.coder.accounts.decode("tickState",n.data);this.tickCache.set(t.tick,{address:e,liquidityNet:u().BigInt(t.liquidityNet)})}}}}const ye=1e6,Me=new c.zt(null,null,{skipPreflight:!1}),Te=new c.$r(T.IDL,G,Me);class ve{constructor(t,e){let n;this.address=void 0,this.label="Cykura",this.id=void 0,this.shouldPrefetch=!0,this.poolState=void 0,this.pool=void 0,this.tickDataProvider=void 0,this.tokens=void 0,this.vaults=void 0,this.swapAccountMetas=[],this.feePct=void 0,this.address=t,this.id=t.toBase58(),n="data"in e?Te.coder.accounts.decode("poolState",e.data):e,this.poolState=n;const{token0:i,token1:r,fee:s,sqrtPriceX32:a,liquidity:c,tick:d}=this.poolState;this.tickDataProvider=new Se(Te,{token0:i,token1:r,fee:s}),this.tokens={token0:new v.Token(101,i,0,"",""),token1:new v.Token(101,r,0,"","")},this.pool=new T.Pool(this.tokens.token0,this.tokens.token1,s,u().BigInt(a.toString()),u().BigInt(c.toString()),d,this.tickDataProvider),this.vaults={vault0:(0,m.findProgramAddressSync)([this.address.toBuffer(),o.TOKEN_PROGRAM_ID.toBuffer(),i.toBuffer()],o.ASSOCIATED_TOKEN_PROGRAM_ID)[0],vault1:(0,m.findProgramAddressSync)([this.address.toBuffer(),o.TOKEN_PROGRAM_ID.toBuffer(),r.toBuffer()],o.ASSOCIATED_TOKEN_PROGRAM_ID)[0]},this.feePct=this.poolState.fee/ye}getAccountsForUpdate(){return[this.address,...this.tickDataProvider.lazyLoadAccountsToCache(this.pool.tickCurrent,this.pool.tickSpacing)]}update(t){const e=t.get(this.address.toBase58());if(!e)throw new Error(`Could not find poolAccountInfo ${this.address.toBase58()}`);this.poolState=Te.coder.accounts.decode("poolState",e.data);const{fee:n,sqrtPriceX32:o,liquidity:i,tick:r}=this.poolState;this.pool=new T.Pool(this.tokens.token0,this.tokens.token1,n,u().BigInt(o.toString()),u().BigInt(i.toString()),r,this.tickDataProvider),this.tickDataProvider.updateCachedAccountInfos(t)}getQuote({sourceMint:t,amount:e}){const n=t.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[o,i,r]=this.pool.getOutputAmount(v.CurrencyAmount.fromRawAmount(n,u().BigInt(e)));this.swapAccountMetas=r;const s=(0,h.YM)(u().subtract(this.pool.sqrtRatioX32,i.sqrtRatioX32)).div(this.pool.sqrtRatioX32.toString());return{notEnoughLiquidity:!1,inAmount:e,outAmount:u().toNumber(o.quotient),feeAmount:Math.floor(e*this.poolState.fee/ye),feeMint:t.toBase58(),feePct:this.feePct,priceImpactPct:s.toNumber()}}createSwapInstructions(t){const[e,n]=t.sourceMint.equals(this.poolState.token0)?[this.vaults.vault0,this.vaults.vault1]:[this.vaults.vault1,this.vaults.vault0],o=(0,m.findProgramAddressSync)([T.OBSERVATION_SEED,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),(0,T.u32ToSeed)(this.poolState.fee),(0,T.u16ToSeed)(this.poolState.observationIndex)],G)[0],i=(0,m.findProgramAddressSync)([T.OBSERVATION_SEED,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),(0,T.u32ToSeed)(this.poolState.fee),(0,T.u16ToSeed)((this.poolState.observationIndex+1)%this.poolState.observationCardinalityNext)],G)[0],r={poolAddress:this.address,inputVault:e,outputVault:n,nextObservationState:i,lastObservationState:o,swapAccountMetas:this.swapAccountMetas};return[bt({...t,additionalArgs:r})]}get reserveTokenMints(){return[this.poolState.token0,this.poolState.token1]}}async function Pe(t,e){const n=(t=>t.map((t=>{const{data:[e,n],pubkey:o,...r}=t;return{...r,pubkey:new i.PublicKey(o),data:B.from(e,n),owner:new i.PublicKey(r.owner)}})))(e),o=[];if(o.length){const e=await async function(t,e){return(await Kt(t,e.map((t=>t.toBase58())))).map(((t,n)=>{const o=e[n];if(!t)throw new Error(`Failed to fetch pool ${o.toBase58()}`);return{pubkey:o,...t}}))}(t,o);n.push(...e)}const a=n.reduce(((t,e)=>{const n=function(t,e,n){const o=new i.PublicKey(e.owner);if(o.equals(D)||o.equals(N)){const t=r.Market.getLayout(o).decode(e.data);if(!t.accountFlags.initialized||!t.accountFlags.market)throw new Error("Invalid market");const n=new r.Market(t,0,0,{},o);return new Wt(n)}if(o.equals(E)){const o=new Rt(t,e,n);if(1===o.status)return o}else{if(o.equals(_))return new de(t,e,n);if(o.equals(s.rb)){const n=s.qp.loadWithData(t,e.data,(0,m.findProgramAddressSync)([t.toBuffer()],s.rb)[0]);if(n.state.isPaused||!n.state.isInitialized)return;return new Qt(n)}if(o.equals(x))return new he(t,e);if(o.equals(K)||o.equals(q))return new ee(t,e,n);if([...oe.keys()].includes(o.toBase58())){var a;const n=null!==(a=oe.get(e.owner.toBase58()))&&void 0!==a?a:"Unknown";return new ae(t,e,n)}if(o.equals(U))return new pe(t,e,n);if(o.equals(R)){const n=new Ae(t,e);if(n.isPaused)return;return n}if(o.equals(L))return new fe(t,e);if(o.equals(W))return new we(t,e);if(o.equals(G))return new ve(t,e)}}(e.pubkey,e,e.params);return n&&t.push(n),t}),new Array);return await(async(t,e)=>{const n=t.map((t=>t.getAccountsForUpdate().map((t=>t.toBase58())))).flat(),o=new Map;(await Kt(e,n)).forEach(((t,e)=>{const i=n[e];t&&o.set(i,t)}));for(let i of t)i.update(o)})(a.filter((t=>t.shouldPrefetch)),t),a.push(...Dt()),a}function Be(t){const e=new Map;return t.forEach((t=>{Et(t.reserveTokenMints).forEach((([n,o])=>{!function(t,e,n,o){let i=o.get(t);i||(i=new Map([[e,[]]]),o.set(t,i));let r=i.get(e);r||(r=[],i.set(e,r));r.push(n)}(n.toBase58(),o.toBase58(),t,e)}))})),e}function be(t){if(t.length>1){const[e,n]=t;if(e instanceof Rt&&n instanceof Rt)return!1}return!0}async function Ie(t,e,n,r,s){const a="string"===typeof r?new i.PublicKey(r):r,u=await o.Token.getAssociatedTokenAddress(o.ASSOCIATED_TOKEN_PROGRAM_ID,o.TOKEN_PROGRAM_ID,a,n,!0),c=[],m=[];return null===await t.getAccountInfo(u)&&m.push(o.Token.createAssociatedTokenAccountInstruction(o.ASSOCIATED_TOKEN_PROGRAM_ID,o.TOKEN_PROGRAM_ID,a,u,n,e)),a.equals(F)&&s&&c.push(o.Token.createCloseAccountInstruction(o.TOKEN_PROGRAM_ID,u,n,n,[])),{address:u,instructions:m,cleanupInstructions:c,signers:[]}}async function Fe({user:t,tokenLedger:e,openOrdersAddresses:n,userSourceTokenAccountAddress:o,userIntermediaryTokenAccountAddress:i,userDestinationTokenAccountAddress:r,routeInfo:s,platformFee:a,quoteMintToReferrer:u}){const c=s.outAmountWithSlippage,m=s.inAmount,d=s.marketInfos.length;if(2===d&&!i)throw new Error("Missing intermediary token account");const p=a&&function(t){if(t.length<2)return!1;const[e,n]=t.map((t=>t.amm));return e instanceof Rt&&n instanceof Wt||e instanceof Wt&&n instanceof Rt}(s.marketInfos)?void 0:u,l=[o,...i?[i]:[],r],h=be(s.marketInfos.map((t=>t.amm))),g=[yt(e,l[1])];for(const[k,w]of s.marketInfos.entries()){const o=w.amm,i=0===k?m:null,r=k===d-1?c:0,s=k===d-1&&h?a:void 0,[u,A]=l.slice(k);g.push(...o.createSwapInstructions({sourceMint:w.inputMint,destinationMint:w.outputMint,userSourceTokenAccount:u,userDestinationTokenAccount:A,userTransferAuthority:t.publicKey,inAmount:i,minimumOutAmount:r,tokenLedger:e,openOrdersAddress:n[k],platformFee:s,quoteMintToReferrer:p}))}const{signers:A,cleanupInstructions:f}={instructions:[],cleanupInstructions:[],signers:[]};return t.isKeyPair&&t.signer&&A.push(t.signer),{signers:A,cleanupInstructions:f,instructions:g}}const De=async(t,e,n,o)=>{const[i,r]=await Promise.all([(async()=>2===e.length?await Ie(t,n,n,e[0].outputMint,o):void 0)(),(async()=>await Ie(t,n,n,2===e.length?e[1].outputMint:e[0].outputMint,o))()]);return{userIntermediaryTokenAccountResult:i,userDestinationTokenAccountResult:r}};async function Ne(t,e,n,o){const r={instructions:[],cleanupInstructions:[],signers:[]},s=n.address.toString();if(o){let e=o.get(s);if(e){let n=null;if(n=await t.getAccountInfo(e,"confirmed"),n)return{...r,address:e}}}const[a,u]=function(t,e){const[n]=(0,m.findProgramAddressSync)([B.from("open_orders"),t.publicKey.toBuffer(),e.toBuffer()],it);return[n,rt.instruction.createOpenOrders({accounts:{openOrders:n,payer:e,dexProgram:t.programId,systemProgram:i.SystemProgram.programId,rent:i.SYSVAR_RENT_PUBKEY,market:t.publicKey}})]}(n,e);return await t.getAccountInfo(a)||(r.instructions=[u]),null===o||void 0===o||o.set(n.address.toString(),a),{...r,address:a}}const Oe=2039280;function Ee(t){return t.reduce(((t,e)=>e+=t),0)}const Ke=async({connection:t,userPublicKey:e,inputMint:n,marketInfos:o,feeCalculator:i,serumOpenOrdersPromise:r,wrapUnwrapSOL:s})=>{const a=n.equals(F)&&s,u=Promise.all(o.map((async n=>{const o=n.amm;if(o instanceof Wt||o instanceof Gt){if(!o.market)return;return await Ne(t,e,o.market,await r)}}))),c=De(t,o,e,s).then((({userIntermediaryTokenAccountResult:t,userDestinationTokenAccountResult:e})=>u.then((n=>({intermediate:t,destination:e,openOrders:n})))));return(({intermediate:t,destination:e,openOrders:n,hasWrapUnwrapSOL:o,feeCalculator:i})=>{const r=n.filter((t=>t&&t.instructions.length>0)).map((()=>23352760)),s=[t,e].filter((t=>(null===t||void 0===t?void 0:t.instructions.length)&&0===t.cleanupInstructions.length)).map((()=>Oe)),a=([...null===n||void 0===n?void 0:n.map((t=>null===t||void 0===t?void 0:t.signers)),null===t||void 0===t?void 0:t.signers,e.signers].filter(Boolean).flat().length+1)*i.lamportsPerSignature;return{signatureFee:a,openOrdersDeposits:r,ataDeposits:s,totalFeeAndDeposits:Ee([a,...r,...s]),minimumSOLForTransaction:Ee([a,...r,...[t,e].filter((t=>{var e;return(null!==(e=null===t||void 0===t?void 0:t.instructions.length)&&void 0!==e?e:0)>0})).map((()=>Oe)),o?Oe:0])}})({...await c,hasWrapUnwrapSOL:a,feeCalculator:i})},qe={feeBps:0,feeAccounts:new Map};async function Ce(t,e){return(await t.getTokenAccountsByOwner(e,{programId:o.TOKEN_PROGRAM_ID})).value.reduce(((t,e)=>{const n=(0,w.nt)(e.account.data);return n&&t.set(n.mint.toBase58(),e.pubkey),t}),new Map)}class Ue{constructor(t,e,n){this.connection=void 0,this.feePayer=void 0,this.instructions=void 0,this.owner=void 0,this.connection=t,this.feePayer=e,this.instructions=[],this.owner=n}addInstruction(t){return this.instructions.push(t),this}async build(t){t||(t=(await this.connection.getLatestBlockhash("confirmed")).blockhash);const e={recentBlockhash:t,feePayer:this.feePayer};let n=[],o=[],r=[];this.instructions.forEach((t=>{n=n.concat(t.instructions),o=o.concat(t.cleanupInstructions),r=r.concat(t.signers)}));const s=new i.Transaction(e);return n.concat(o).forEach((t=>s.add(t))),s.feePayer=this.feePayer,{transaction:s,signers:r,execute:this.owner.isKeyPair?()=>this.connection.sendTransaction(s,r):async()=>{throw new Error("Please use a Keypair for the owner parameter to enable the execute function")}}}}class Re{constructor(t){this._owner=void 0,this._owner=t}get publicKey(){return Re.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return Re.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return Re.isKeyPair(this._owner)}get isPublicKey(){return Re.isPublicKey(this._owner)}static isKeyPair(t){return void 0!==t.secretKey}static isPublicKey(t){return!Re.isKeyPair(t)}}const Le=t=>new Promise((e=>setTimeout(e,t)));function xe(t,e,n){const o=e.message;if(!t)return;return function(t,e){var n,o,i,r;const s=null===(n=e.postTokenBalances)||void 0===n||null===(o=n.find((e=>e.accountIndex===t)))||void 0===o?void 0:o.uiTokenAmount.amount,a=null===(i=e.preTokenBalances)||void 0===i||null===(r=i.find((e=>e.accountIndex===t)))||void 0===r?void 0:r.uiTokenAmount.amount;if(s)return Math.abs(parseInt(s)-(void 0!==a?parseInt(a):0))}(o.accountKeys.findIndex((t=>t.equals(n))),t)}function Ve(t,e,n){let o=e.message.accountKeys.findIndex((t=>t.equals(n)));return-1!==o?Math.abs(t.postBalances[o]-t.preBalances[o]):0}function _e(){return(new Date).getTime()}const We={skipPreflight:!0,maxRetries:2};async function Ge(t,e,n=12e4,o=500,i=2e3,r=40){const s=e.serialize(),a=await t.sendRawTransaction(s,We),u=_e();let c=_e(),m=0;for(;_e()-u<n;){const e=_e();m<r&&e-c>i&&(c=e,m+=1,await t.sendRawTransaction(s,We));const n=await Promise.any([t.getTransaction(a,{commitment:"confirmed"}),Le(5e3)]);if(n)return{txid:a,transactionResponse:n};await Le(o)}return{txid:a,transactionResponse:null}}function ze(t){const e=t.signature;if(!e)throw new Error("Transaction has no signature");return P.bs58.encode(e)}const Qe=function(t){if(!Array.isArray(t))throw new TypeError(`Argument must be an array: ${t}`)},He=function({length:t}){if(t>=je)throw new TypeError(`Too many arrays (${t}): please use the 'big-cartesian' library instead of 'fast-cartesian'`)},je=100,Ye=function(t){const e=t.reduce(Xe,1);if(e>=Ze){const t=Number.isFinite(e)?` (${e.toExponential(0)})`:"";throw new TypeError(`Too many combinations${t}: please use the 'big-cartesian' library instead of 'fast-cartesian'`)}},Xe=function(t,e){return t*e.length},Ze=4294967296;function Je(t){if(function(t){if(!Array.isArray(t))throw new TypeError("Argument must be an array of arrays");t.forEach(Qe),He(t),Ye(t)}(t),0===t.length)return[];const e=[];return $e(t.length)(t,e),e}const $e=function(t){const e=tn[t];if(void 0!==e)return e;const n=en(t);return tn[t]=n,n},tn={},en=function(t){const e=Array.from({length:t},nn),n=e.map((t=>`for (const value${t} of arrays[${t}]) {`)).join("\n"),o=e.map((t=>`value${t}`)).join(", "),i="}\n".repeat(t);return new Function("arrays","result",`${n}\nresult.push([${o}])\n${i}`)},nn=function(t,e){return String(e)};function on({inputMint:t,outputMint:e}){return`${t}-${e}`}function rn({ammId:t,amount:e}){return`${t}-${e}`}function sn({inputRouteSegment:t,inputMint:e,outputMint:n,amount:o,getDepositAndFeeForRoute:r,platformFeeBps:s,slippage:a,filterTopNResult:u,onlyDirectRoutes:c}){const m=e.toBase58(),d=n.toBase58(),p=new Map,l=t.get(m),h=[];if(!l)throw new Error("No routes found for the input and output mints");const g=c?0:2,A=({inputMint:e,level:n=0,walked:r=[e]})=>{const s=t.get(e);s&&s.forEach(((a,m)=>{const l=on({inputMint:e,outputMint:m}),f=function({amms:t,inputMint:e,outputMint:n,amount:o,filterTopNResult:r=3}){const s=t.map((t=>{try{return{quote:t.getQuote({amount:o,sourceMint:new i.PublicKey(e),destinationMint:new i.PublicKey(n)}),id:t.id}}catch(r){return}})).sort(((t,e)=>((null===e||void 0===e?void 0:e.quote.outAmount)||0)-((null===t||void 0===t?void 0:t.quote.outAmount)||0))).filter(((t,e)=>t&&t.quote.inAmount&&e<r));return new Map(s.map((t=>[rn({ammId:t.id,amount:o}),t.quote])))}({amms:a,inputMint:e,outputMint:m,amount:o,filterTopNResult:u}),k=a.filter((t=>f.has(rn({ammId:t.id,amount:o}))));if(m!==d||c||function(t,e){for(let n=0;n<t.length;n++)for(let o=n+1;o<t.length;o++)t[n].label!==t[o].label&&e(t[n],t[o])}(k.slice(),((t,e)=>{const n=Gt.create(t,e);n&&k.push(n)})),s.set(m,k),p.set(l,f),m!==d&&f.size&&!r.includes(m)&&n<g-1)A({inputMint:m,amount:f.values().next().value.outAmount,level:n+1,walked:r.concat(m)});else if(m===d){const e=r.concat(m),n=e.map((t=>new i.PublicKey(t)));Je(e.reduce(((n,o,i)=>{var r;i<e.length-1&&n.push(null===(r=t.get(e[i]))||void 0===r?void 0:r.get(e[i+1]));return n}),[])).forEach((t=>{(1===t.length||zt(t[0],t[1]))&&h.push({amms:t,mints:n})}))}}))};A({inputMint:m,amount:o});return h.map((t=>{const{amms:e,mints:n}=t;let i=[],u=o,c=o;const m=be(e),d=n,l=e.length;for(const[o,r]of e.entries())try{var h;const t=d[o],e=d[o+1],n=on({inputMint:t.toBase58(),outputMint:e.toBase58()}),g=(null===(h=p.get(n))||void 0===h?void 0:h.get(rn({ammId:r.id,amount:u})))||r.getQuote({sourceMint:t,destinationMint:e,amount:u}),A=l-1===o&&m?{amount:Math.floor(g.outAmount*s/1e4),mint:e.toBase58(),pct:s/100}:{amount:0,mint:e.toBase58(),pct:0},f=Math.max(0,g.outAmount-A.amount),k=Math.round(f*(1-a/100));i.push({amm:r,inputMint:t,outputMint:e,notEnoughLiquidity:g.notEnoughLiquidity,minInAmount:g.minInAmount,minOutAmount:g.minOutAmount,inAmount:g.inAmount,outAmount:f,priceImpactPct:g.priceImpactPct,lpFee:{amount:g.feeAmount,mint:g.feeMint,pct:g.feePct},platformFee:A}),u=f,c=k}catch(g){return void 0}return{marketInfos:i,getDepositAndFee:()=>r({marketInfos:i}),inAmount:i[0].inAmount,outAmount:u,outAmountWithSlippage:c,priceImpactPct:1-i.reduce(((t,e)=>t*=1-e.priceImpactPct),1)}})).filter((t=>void 0!==t)).sort(((t,e)=>e.outAmount-t.outAmount))}async function an({txid:t,transactionResponse:e}){var n;if(!e)throw new w.qw("Transaction was not confirmed",t);if(null!==e&&void 0!==e&&null!==(n=e.meta)&&void 0!==n&&n.err){let{message:n,code:o}=await(0,w.nR)(e);switch(o){case 6e3:n="Slippage error"}throw new w.qw(n||"",t,o)}return{txid:t,transactionResponse:e}}class un{constructor(t,e,n,r,s,a,u=0,c=!0,m,d,p){this.connection=void 0,this.cluster=void 0,this.tokenRouteSegments=void 0,this.feeCalculator=void 0,this.platformFeeAndAccounts=void 0,this.quoteMintToReferrer=void 0,this.routeCacheDuration=void 0,this.wrapUnwrapSOL=void 0,this.tokenLedger=void 0,this.intermediateTokens=void 0,this.shouldLoadSerumOpenOrders=void 0,this.serumOpenOrdersPromise=void 0,this.user=void 0,this.routeCache=new Map,this.getDepositAndFees=async({marketInfos:t,userPublicKey:e,serumOpenOrdersPromise:n=Promise.resolve(new Map)})=>Ke({connection:this.connection,feeCalculator:this.feeCalculator,inputMint:t[0].inputMint,marketInfos:t,serumOpenOrdersPromise:n,userPublicKey:e,wrapUnwrapSOL:this.wrapUnwrapSOL}),this.getDepositAndFeesForUser=({marketInfos:t})=>{if(this.user&&this.serumOpenOrdersPromise){const e=new Re(this.user);return this.getDepositAndFees({marketInfos:t,userPublicKey:e.publicKey,serumOpenOrdersPromise:this.serumOpenOrdersPromise})}return Promise.resolve(void 0)},this.exchange=async({routeInfo:t,userPublicKey:e,feeAccount:n,wrapUnwrapSOL:r,tokenLedger:s})=>{var a;const{connection:u,serumOpenOrdersPromise:c}=this,m=e||this.user;if(!m)throw new Error("user not found");const d=new Re(m),p=t.marketInfos.length-1,l=t.marketInfos[0].inputMint,h=t.marketInfos[p].outputMint,g=null!==r&&void 0!==r?r:this.wrapUnwrapSOL,[A,f]=await Promise.all([De(u,t.marketInfos,d.publicKey,g),Promise.all(t.marketInfos.map((async({amm:t})=>{if(t instanceof Wt||t instanceof Gt){if(!t.market)return;return await Ne(u,d.publicKey,t.market,await c)}})))]),k={intermediate:A.userIntermediaryTokenAccountResult,destination:A.userDestinationTokenAccountResult,openOrders:f},w=k.openOrders.filter(Boolean).length>0,S=l.equals(F)&&g?await async function(t,e,n){const r={instructions:[],cleanupInstructions:[],signers:[]};r.instructions=[];const s=await o.Token.getAssociatedTokenAddress(o.ASSOCIATED_TOKEN_PROGRAM_ID,o.TOKEN_PROGRAM_ID,F,e,!0);return null===await t.getAccountInfo(s)&&r.instructions.push(o.Token.createAssociatedTokenAccountInstruction(o.ASSOCIATED_TOKEN_PROGRAM_ID,o.TOKEN_PROGRAM_ID,F,s,e,e)),r.instructions.push(i.SystemProgram.transfer({fromPubkey:e,toPubkey:s,lamports:n})),r.instructions.push(o.Token.createSyncNativeInstruction(o.TOKEN_PROGRAM_ID,s)),r.cleanupInstructions=[o.Token.createCloseAccountInstruction(o.TOKEN_PROGRAM_ID,s,e,e,[])],{address:s,...r}}(u,d.publicKey,t.inAmount):{instructions:[],cleanupInstructions:[],signers:[],address:await o.Token.getAssociatedTokenAddress(o.ASSOCIATED_TOKEN_PROGRAM_ID,o.TOKEN_PROGRAM_ID,l,d.publicKey,!0)},y=(n=n||this.platformFeeAndAccounts.feeAccounts.get(h.toBase58()))?{feeBps:this.platformFeeAndAccounts.feeBps||Math.floor(100*t.marketInfos[p].platformFee.pct),feeAccount:n}:void 0,M=await Fe({user:d,tokenLedger:s||this.tokenLedger,openOrdersAddresses:k.openOrders.map((t=>null===t||void 0===t?void 0:t.address)),userSourceTokenAccountAddress:S.address,userIntermediaryTokenAccountAddress:null===(a=k.intermediate)||void 0===a?void 0:a.address,userDestinationTokenAccountAddress:k.destination.address,routeInfo:t,platformFee:y,quoteMintToReferrer:this.quoteMintToReferrer}),{needCleanup:T,needSetup:v}=function(t,{hasSerumOpenOrderInstruction:e}){let n,o;if(1===t.length){const e=t[0].amm;if(!(e instanceof Gt))return{needSetup:!1,needCleanup:!1};n=e.firstAmm,o=e.secondAmm}else[n,o]=t.map((t=>t.amm));return n instanceof Rt||o instanceof Rt||n instanceof Wt&&o instanceof Wt?{needSetup:!0,needCleanup:!0}:e?{needSetup:!0,needCleanup:!1}:{needSetup:!1,needCleanup:!1}}(t.marketInfos,{hasSerumOpenOrderInstruction:w}),P=new Ue(u,d.publicKey,d),B=new Ue(u,d.publicKey,d),b=new Ue(u,d.publicKey,d),I=[k.intermediate,S,!k.destination.address.equals(S.address)&&k.destination];v?(w&&k.openOrders.forEach((t=>{t&&P.addInstruction(t)})),I.forEach((t=>{if(t&&(P.addInstruction({...t,cleanupInstructions:[]}),t.cleanupInstructions.length)){const e={instructions:[],cleanupInstructions:[],signers:[],cleanupInstructions:t.cleanupInstructions};T?b.addInstruction(e):B.addInstruction(e)}}))):(w&&k.openOrders.forEach((t=>{t&&B.addInstruction(t)})),I.forEach((t=>{t&&B.addInstruction(t)}))),B.addInstruction(M);const D=(await this.connection.getLatestBlockhash("confirmed")).blockhash,{transaction:N}=await P.build(D),{transaction:O}=await B.build(D),{transaction:E}=await b.build(D),[K,q,C]=[N.instructions.length?N:void 0,O,E.instructions.length?E:void 0],U=k;return{transactions:{setupTransaction:K,swapTransaction:q,cleanupTransaction:C},execute:({wallet:t,onTransaction:e}={})=>this.executeInternal({wallet:t,onTransaction:e,inputMint:l,outputMint:h,sourceInstruction:S,setupInstructions:U,setupTransaction:K,swapTransaction:q,cleanupTransaction:C,wrapUnwrapSOL:g,owner:d})}},this.connection=t,this.cluster=e,this.tokenRouteSegments=n,this.feeCalculator=r,this.platformFeeAndAccounts=s,this.quoteMintToReferrer=a,this.routeCacheDuration=u,this.wrapUnwrapSOL=c,this.tokenLedger=m,this.intermediateTokens=d,this.shouldLoadSerumOpenOrders=p}static async load({connection:t,cluster:e,user:n,platformFeeAndAccounts:o=qe,quoteMintToReferrer:r,routeCacheDuration:s=0,wrapUnwrapSOL:a=!0,marketUrl:u,restrictIntermediateTokens:c=!1,tokenLedger:m=at,shouldLoadSerumOpenOrders:d=!0}){const[p,{value:{feeCalculator:l}},h,g]=await Promise.all([un.fetchTokenRouteSegments(t,e,u),t.getRecentBlockhashAndContext("processed"),null!==r&&void 0!==r?r:Ce(t,new i.PublicKey(V)),c?un.getIntermediateTokens():void 0]),A=new un(t,e,p,l,o,h,s,a,m,g,d);return n&&A.setUserPublicKey(n),A}getAccountToAmmMap(){const t=new Map;return this.tokenRouteSegments.forEach((e=>{Array.from(e.values()).forEach((e=>{e.forEach((e=>{e.getAccountsForUpdate().forEach((n=>{t.set(n.toBase58(),e)}))}))}))})),t}async computeRoutes({inputMint:t,outputMint:e,inputAmount:n,slippage:o,feeBps:i=0,forceFetch:r,onlyDirectRoutes:s,filterTopNResult:a}){const u=t.toBase58(),c=e.toBase58(),m=i||(this.platformFeeAndAccounts.feeAccounts.get(c)?this.platformFeeAndAccounts.feeBps:0),d=(new Date).getTime(),p=[u,c].sort(((t,e)=>t.localeCompare(e))).join(""),l=this.routeCache.get(p),h=function({inputMint:t,outputMint:e,tokenRouteSegments:n,intermediateTokens:o}){const i=new Map,r=n.get(t),s=n.get(e);if(r&&s){const n=new Map,a=new Map;for(let[u,c]of r.entries()){if(u===e){n.set(u,c),a.set(t,c);continue}if(o&&!o.includes(u))continue;const r=s.get(u);r&&(i.set(u,new Map([[t,c],[e,r]])),n.set(u,c),a.set(u,r))}i.set(t,n),i.set(e,a)}return i}({inputMint:u,outputMint:c,tokenRouteSegments:this.tokenRouteSegments,intermediateTokens:this.intermediateTokens});let g=!1;if(-1===this.routeCacheDuration)g=!1;else if(0===this.routeCacheDuration)g=!0;else if(l){const{fetchTimestamp:t}=l;d-t>this.routeCacheDuration&&(g=!0)}else g=!0;(r||g)&&(await async function(t,e){const n=new Map,o=new Set,i=new Map;e.forEach((t=>{t.forEach((t=>{t.forEach((t=>{i.set(t.id,t),t.getAccountsForUpdate().forEach((t=>{o.add(t.toBase58())}))}))}))}));const r=Array.from(o);r.length>0&&((await Kt(t,r)).forEach(((t,e)=>{const o=r[e];t&&n.set(o,t)})),i.forEach((t=>{t.update(n)})))}(this.connection,h),this.routeCache.set(p,{fetchTimestamp:(new Date).getTime()}));try{return{routesInfos:sn({inputRouteSegment:h,inputMint:t,outputMint:e,amount:n,getDepositAndFeeForRoute:this.getDepositAndFeesForUser,onlyDirectRoutes:s,slippage:o,platformFeeBps:m,filterTopNResult:a}),cached:!(r||g)}}catch(A){throw A}finally{this.routeCache.forEach((({fetchTimestamp:t},e)=>{t-d>this.routeCacheDuration&&this.routeCache.delete(e)}))}}setUserPublicKey(t){this.user=t;const e=new Re(this.user);this.serumOpenOrdersPromise=this.shouldLoadSerumOpenOrders?un.findSerumOpenOrdersForOwner({connection:this.connection,cluster:this.cluster,userPublicKey:e.publicKey}):Promise.resolve(new Map)}static async fetchTokenRouteSegments(t,e,n){const o=await(async t=>await(await k()(t)).json())(n||O[e]);return Be(await Pe(t,o))}getRouteMap(t){return function(t,e,n){const o=new Map;for(const[r,s]of t){const a=new Set;for(const[o,u]of s){var i;if(a.add(o),n)continue;const s=null!==(i=t.get(o))&&void 0!==i?i:[];for(const[t,n]of s)if(t!==r&&(!e||e.includes(o)))for(const e of u)for(const o of n)if(zt(e,o)){a.add(t);break}}o.set(r,Array.from(a))}return o}(this.tokenRouteSegments,this.intermediateTokens,t)}async executeInternal({wallet:t,onTransaction:e,inputMint:n,outputMint:o,sourceInstruction:i,setupInstructions:r,setupTransaction:s,swapTransaction:a,cleanupTransaction:u,owner:c,wrapUnwrapSOL:m}){try{const p=[s,a,u].filter((t=>void 0!==t)),l=p.length;if(c.signer){const t=c.signer;p.forEach((e=>{e.sign(t)}))}else{if(!t)throw new Error("Signer wallet not found");l>1?await t.signAllTransactions(p):await t.signTransaction(p[0])}let h,g;s&&(null===e||void 0===e||e(ze(s),l,"SETUP"),await an(await Ge(this.connection,s))),null===e||void 0===e||e(ze(a),l,"SWAP");try{const{txid:t,transactionResponse:s}=await an(await Ge(this.connection,a)),[d,p]=function({txid:t,inputMint:e,outputMint:n,user:o,sourceAddress:i,destinationAddress:r,transactionResponse:s,hasWrappedSOL:a}){let u,c;if(s){let{meta:t,transaction:m}=s;t&&(u=e.equals(F)&&!a?Ve(t,m,o):xe(t,m,i),c=n.equals(F)&&!a?Ve(t,m,o):xe(t,m,r))}if(!u||!c)throw new w.qw("Cannot find source or destination token account balance change",t,H.BalancesNotExtractedProperly.code);return[u,c]}({txid:t,inputMint:n,outputMint:o,user:c.publicKey,sourceAddress:i.address,destinationAddress:r.destination.address,transactionResponse:s,hasWrappedSOL:Boolean(u)||!m});g={txid:t,inputAddress:i.address,outputAddress:r.destination.address,inputAmount:d,outputAmount:p}}catch(d){h=d}finally{u&&(null===e||void 0===e||e(ze(u),l,"CLEANUP"),await Ge(this.connection,u))}if(h||!g)throw h||new Error("Swap failed");return g}catch(p){return{error:p}}finally{this.routeCache.clear()}}static async getIntermediateTokens(){const t=await async function(){const t=await(await k()("https://cache.jup.ag/top-tokens")).json();return new Set(t.filter(((t,e)=>e<60)))}();for(const e of Q)t.add(e);return Dt().forEach((e=>{t.add(e.wrappedToken.addDecimals.mint.toBase58())})),Array.from(t)}}un.findSerumOpenOrdersForOwner=async({userPublicKey:t,cluster:e,connection:n})=>{const o=new Map;if(t){const i="mainnet-beta"===e?D:N;(await r.OpenOrders.findForOwner(n,t,i)).forEach((t=>{o.set(t.market.toString(),t.address)}))}return o},un.createInitializeTokenLedgerInstruction=function(t,e){return rt.instruction.initializeTokenLedger({accounts:{tokenLedger:t,payer:e,systemProgram:i.SystemProgram.programId}})}}}]);